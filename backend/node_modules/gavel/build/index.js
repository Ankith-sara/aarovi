(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.gavel = {}));
}(this, function (exports) { 'use strict';

  function isset(value) {
    return value != null;
  }

  var isset_1 = isset;

  /**
   * Applies a given evolution schema to the given data Object.
   * Properties not present in schema are bypassed.
   * Properties not present in data are ignored.
   * @param {Object<string, any>} schema
   * @param {any[]|Object<string, any>} data
   * @returns {any[]|Object<string, any>}
   */
  const evolve = (schema, { strict = false } = {}) => (data) => {
    const dataType = typeof data;
    const schemaType = typeof schema;
    const isArray = Array.isArray(data);
    const result = isArray ? [] : {};

    if (!(schema !== null && schemaType === 'object' && !Array.isArray(schema))) {
      throw new Error(
        `Failed to evolve: expected transformations schema to be an object, but got: ${schemaType}`
      );
    }

    if (dataType !== 'object') {
      throw new Error(
        `Failed to evolve: expected data to be an instance of array or object, but got: ${dataType}`
      );
    }

    const reducer = (acc, key) => {
      const value = data[key];
      const transform = schema[key];
      const transformType = typeof transform;

      /* eslint-disable no-nested-ternary */
      const nextValue =
        transformType === 'function'
          ? transform(value)
          : transform && transformType === 'object'
          ? evolve(transform)(value)
          : value;
      /* eslint-enable no-nested-ternary */

      return isArray
        ? acc.concat(nextValue)
        : Object.assign({}, acc, { [key]: nextValue });
    };

    const nextData = Object.keys(data).reduce(reducer, result);

    if (strict) {
      // Strict mode ensures all keys in expected schema are present
      // in the returned payload.
      return Object.keys(schema)
        .filter((expectedKey) => {
          return !Object.prototype.hasOwnProperty.call(data, expectedKey);
        })
        .reduce(reducer, nextData);
    }

    return nextData;
  };

  var evolve_1 = evolve;

  /**
   * Accepts a fallback value and returns an ensuring function
   * that uses the fallback value in case real one is not provided.
   */
  const otherwise = (fallbackValue) => (realValue) => {
    return realValue || fallbackValue;
  };

  var otherwise_1 = otherwise;

  const coercionMap = {
    method: otherwise_1(''),
    uri: otherwise_1(''),
    headers: otherwise_1({}),
    body: otherwise_1('')
  };

  // Coercion is strict by default, meaning it would populate
  // all the keys illegible for coercion on the given object,
  // even if those keys are missing.
  const coerce = evolve_1(coercionMap, { strict: true });

  // There is also a weak variant of coercion that operates
  // only on the present keys in the given object.
  // This is used for coercing expected HTTP message, for example.
  const coerceWeak = evolve_1(coercionMap);

  var coerce_1 = {
    coerce,
    coerceWeak
  };

  /**
   * Normalizes given method.
   * @param {string} method
   * @returns {string}
   */
  const normalizeMethod = (method) => {
    return method.trim().toUpperCase();
  };

  var normalizeMethod_1 = { normalizeMethod };

  /**
   * Normalizes given status code.
   * @param {string} value
   * @returns {string}
   */
  function normalizeStatusCode(value) {
    return value == null ? '' : String(value).trim();
  }

  var normalizeStatusCode_1 = { normalizeStatusCode };

  const normalizeStringValue = (value) => {
    return value.toLowerCase();
  };

  /**
   * Normalizes given headers.
   * @param {Object<string, string>} headers
   * @returns {Object<string, string>}
   */
  const normalizeHeaders = (headers) => {
    const headersType = typeof headers;
    const isHeadersNull = headers == null;

    if (isHeadersNull || headersType !== 'object') {
      throw new Error(
        `Can't validate: expected "headers" to be an Object, but got: ${
        isHeadersNull ? 'null' : headersType
      }.`
      );
    }

    return Object.keys(headers).reduce(
      (normalizedHeaders, name) =>
        Object.assign({}, normalizedHeaders, {
          [name.toLowerCase()]:
            typeof headers[name] === 'string'
              ? normalizeStringValue(headers[name])
              : headers[name]
        }),
      {}
    );
  };

  var normalizeHeaders_1 = { normalizeHeaders };

  const { normalizeMethod: normalizeMethod$1 } = normalizeMethod_1;
  const { normalizeStatusCode: normalizeStatusCode$1 } = normalizeStatusCode_1;
  const { normalizeHeaders: normalizeHeaders$1 } = normalizeHeaders_1;

  const normalize = evolve_1({
    method: normalizeMethod$1,
    statusCode: normalizeStatusCode$1,
    headers: normalizeHeaders$1
  });

  var normalize_1 = { normalize };

  /**
   * Concludes HTTP message's component validity based on the given
   * list of validation errors.
   * @param {Object<string, any>} errors
   * @returns {boolean}
   */
  function isValidField({ errors }) {
    return errors.length === 0;
  }

  /**
   * Returns a boolean indicating the given validation result as valid.
   * @param {Object<string, any>} fields
   * @returns {boolean}
   */
  function isValidResult(fields) {
    return Object.values(fields).every(isValidField);
  }

  var isValid = {
    isValidResult,
    isValidField
  };

  function validateMethod(expected, actual) {
    const values = {
      expected: expected.method,
      actual: actual.method
    };
    const valid = values.actual === values.expected;
    const errors = [];

    if (!valid) {
      errors.push({
        message: `Expected method '${values.expected}', but got '${values.actual}'.`
      });
    }

    return {
      valid,
      kind: 'text',
      values,
      errors
    };
  }

  var validateMethod_1 = { validateMethod };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var punycode = createCommonjsModule(function (module, exports) {
  (function(root) {

  	/** Detect free variables */
  	var freeExports =  exports &&
  		!exports.nodeType && exports;
  	var freeModule =  module &&
  		!module.nodeType && module;
  	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;
  	if (
  		freeGlobal.global === freeGlobal ||
  		freeGlobal.window === freeGlobal ||
  		freeGlobal.self === freeGlobal
  	) {
  		root = freeGlobal;
  	}

  	/**
  	 * The `punycode` object.
  	 * @name punycode
  	 * @type Object
  	 */
  	var punycode,

  	/** Highest positive signed 32-bit float value */
  	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

  	/** Bootstring parameters */
  	base = 36,
  	tMin = 1,
  	tMax = 26,
  	skew = 38,
  	damp = 700,
  	initialBias = 72,
  	initialN = 128, // 0x80
  	delimiter = '-', // '\x2D'

  	/** Regular expressions */
  	regexPunycode = /^xn--/,
  	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
  	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

  	/** Error messages */
  	errors = {
  		'overflow': 'Overflow: input needs wider integers to process',
  		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
  		'invalid-input': 'Invalid input'
  	},

  	/** Convenience shortcuts */
  	baseMinusTMin = base - tMin,
  	floor = Math.floor,
  	stringFromCharCode = String.fromCharCode,

  	/** Temporary variable */
  	key;

  	/*--------------------------------------------------------------------------*/

  	/**
  	 * A generic error utility function.
  	 * @private
  	 * @param {String} type The error type.
  	 * @returns {Error} Throws a `RangeError` with the applicable error message.
  	 */
  	function error(type) {
  		throw RangeError(errors[type]);
  	}

  	/**
  	 * A generic `Array#map` utility function.
  	 * @private
  	 * @param {Array} array The array to iterate over.
  	 * @param {Function} callback The function that gets called for every array
  	 * item.
  	 * @returns {Array} A new array of values returned by the callback function.
  	 */
  	function map(array, fn) {
  		var length = array.length;
  		var result = [];
  		while (length--) {
  			result[length] = fn(array[length]);
  		}
  		return result;
  	}

  	/**
  	 * A simple `Array#map`-like wrapper to work with domain name strings or email
  	 * addresses.
  	 * @private
  	 * @param {String} domain The domain name or email address.
  	 * @param {Function} callback The function that gets called for every
  	 * character.
  	 * @returns {Array} A new string of characters returned by the callback
  	 * function.
  	 */
  	function mapDomain(string, fn) {
  		var parts = string.split('@');
  		var result = '';
  		if (parts.length > 1) {
  			// In email addresses, only the domain name should be punycoded. Leave
  			// the local part (i.e. everything up to `@`) intact.
  			result = parts[0] + '@';
  			string = parts[1];
  		}
  		// Avoid `split(regex)` for IE8 compatibility. See #17.
  		string = string.replace(regexSeparators, '\x2E');
  		var labels = string.split('.');
  		var encoded = map(labels, fn).join('.');
  		return result + encoded;
  	}

  	/**
  	 * Creates an array containing the numeric code points of each Unicode
  	 * character in the string. While JavaScript uses UCS-2 internally,
  	 * this function will convert a pair of surrogate halves (each of which
  	 * UCS-2 exposes as separate characters) into a single code point,
  	 * matching UTF-16.
  	 * @see `punycode.ucs2.encode`
  	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
  	 * @memberOf punycode.ucs2
  	 * @name decode
  	 * @param {String} string The Unicode input string (UCS-2).
  	 * @returns {Array} The new array of code points.
  	 */
  	function ucs2decode(string) {
  		var output = [],
  		    counter = 0,
  		    length = string.length,
  		    value,
  		    extra;
  		while (counter < length) {
  			value = string.charCodeAt(counter++);
  			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
  				// high surrogate, and there is a next character
  				extra = string.charCodeAt(counter++);
  				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
  					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
  				} else {
  					// unmatched surrogate; only append this code unit, in case the next
  					// code unit is the high surrogate of a surrogate pair
  					output.push(value);
  					counter--;
  				}
  			} else {
  				output.push(value);
  			}
  		}
  		return output;
  	}

  	/**
  	 * Creates a string based on an array of numeric code points.
  	 * @see `punycode.ucs2.decode`
  	 * @memberOf punycode.ucs2
  	 * @name encode
  	 * @param {Array} codePoints The array of numeric code points.
  	 * @returns {String} The new Unicode string (UCS-2).
  	 */
  	function ucs2encode(array) {
  		return map(array, function(value) {
  			var output = '';
  			if (value > 0xFFFF) {
  				value -= 0x10000;
  				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
  				value = 0xDC00 | value & 0x3FF;
  			}
  			output += stringFromCharCode(value);
  			return output;
  		}).join('');
  	}

  	/**
  	 * Converts a basic code point into a digit/integer.
  	 * @see `digitToBasic()`
  	 * @private
  	 * @param {Number} codePoint The basic numeric code point value.
  	 * @returns {Number} The numeric value of a basic code point (for use in
  	 * representing integers) in the range `0` to `base - 1`, or `base` if
  	 * the code point does not represent a value.
  	 */
  	function basicToDigit(codePoint) {
  		if (codePoint - 48 < 10) {
  			return codePoint - 22;
  		}
  		if (codePoint - 65 < 26) {
  			return codePoint - 65;
  		}
  		if (codePoint - 97 < 26) {
  			return codePoint - 97;
  		}
  		return base;
  	}

  	/**
  	 * Converts a digit/integer into a basic code point.
  	 * @see `basicToDigit()`
  	 * @private
  	 * @param {Number} digit The numeric value of a basic code point.
  	 * @returns {Number} The basic code point whose value (when used for
  	 * representing integers) is `digit`, which needs to be in the range
  	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  	 * used; else, the lowercase form is used. The behavior is undefined
  	 * if `flag` is non-zero and `digit` has no uppercase form.
  	 */
  	function digitToBasic(digit, flag) {
  		//  0..25 map to ASCII a..z or A..Z
  		// 26..35 map to ASCII 0..9
  		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  	}

  	/**
  	 * Bias adaptation function as per section 3.4 of RFC 3492.
  	 * http://tools.ietf.org/html/rfc3492#section-3.4
  	 * @private
  	 */
  	function adapt(delta, numPoints, firstTime) {
  		var k = 0;
  		delta = firstTime ? floor(delta / damp) : delta >> 1;
  		delta += floor(delta / numPoints);
  		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
  			delta = floor(delta / baseMinusTMin);
  		}
  		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  	}

  	/**
  	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  	 * symbols.
  	 * @memberOf punycode
  	 * @param {String} input The Punycode string of ASCII-only symbols.
  	 * @returns {String} The resulting string of Unicode symbols.
  	 */
  	function decode(input) {
  		// Don't use UCS-2
  		var output = [],
  		    inputLength = input.length,
  		    out,
  		    i = 0,
  		    n = initialN,
  		    bias = initialBias,
  		    basic,
  		    j,
  		    index,
  		    oldi,
  		    w,
  		    k,
  		    digit,
  		    t,
  		    /** Cached calculation results */
  		    baseMinusT;

  		// Handle the basic code points: let `basic` be the number of input code
  		// points before the last delimiter, or `0` if there is none, then copy
  		// the first basic code points to the output.

  		basic = input.lastIndexOf(delimiter);
  		if (basic < 0) {
  			basic = 0;
  		}

  		for (j = 0; j < basic; ++j) {
  			// if it's not a basic code point
  			if (input.charCodeAt(j) >= 0x80) {
  				error('not-basic');
  			}
  			output.push(input.charCodeAt(j));
  		}

  		// Main decoding loop: start just after the last delimiter if any basic code
  		// points were copied; start at the beginning otherwise.

  		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

  			// `index` is the index of the next character to be consumed.
  			// Decode a generalized variable-length integer into `delta`,
  			// which gets added to `i`. The overflow checking is easier
  			// if we increase `i` as we go, then subtract off its starting
  			// value at the end to obtain `delta`.
  			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

  				if (index >= inputLength) {
  					error('invalid-input');
  				}

  				digit = basicToDigit(input.charCodeAt(index++));

  				if (digit >= base || digit > floor((maxInt - i) / w)) {
  					error('overflow');
  				}

  				i += digit * w;
  				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

  				if (digit < t) {
  					break;
  				}

  				baseMinusT = base - t;
  				if (w > floor(maxInt / baseMinusT)) {
  					error('overflow');
  				}

  				w *= baseMinusT;

  			}

  			out = output.length + 1;
  			bias = adapt(i - oldi, out, oldi == 0);

  			// `i` was supposed to wrap around from `out` to `0`,
  			// incrementing `n` each time, so we'll fix that now:
  			if (floor(i / out) > maxInt - n) {
  				error('overflow');
  			}

  			n += floor(i / out);
  			i %= out;

  			// Insert `n` at position `i` of the output
  			output.splice(i++, 0, n);

  		}

  		return ucs2encode(output);
  	}

  	/**
  	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
  	 * Punycode string of ASCII-only symbols.
  	 * @memberOf punycode
  	 * @param {String} input The string of Unicode symbols.
  	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
  	 */
  	function encode(input) {
  		var n,
  		    delta,
  		    handledCPCount,
  		    basicLength,
  		    bias,
  		    j,
  		    m,
  		    q,
  		    k,
  		    t,
  		    currentValue,
  		    output = [],
  		    /** `inputLength` will hold the number of code points in `input`. */
  		    inputLength,
  		    /** Cached calculation results */
  		    handledCPCountPlusOne,
  		    baseMinusT,
  		    qMinusT;

  		// Convert the input in UCS-2 to Unicode
  		input = ucs2decode(input);

  		// Cache the length
  		inputLength = input.length;

  		// Initialize the state
  		n = initialN;
  		delta = 0;
  		bias = initialBias;

  		// Handle the basic code points
  		for (j = 0; j < inputLength; ++j) {
  			currentValue = input[j];
  			if (currentValue < 0x80) {
  				output.push(stringFromCharCode(currentValue));
  			}
  		}

  		handledCPCount = basicLength = output.length;

  		// `handledCPCount` is the number of code points that have been handled;
  		// `basicLength` is the number of basic code points.

  		// Finish the basic string - if it is not empty - with a delimiter
  		if (basicLength) {
  			output.push(delimiter);
  		}

  		// Main encoding loop:
  		while (handledCPCount < inputLength) {

  			// All non-basic code points < n have been handled already. Find the next
  			// larger one:
  			for (m = maxInt, j = 0; j < inputLength; ++j) {
  				currentValue = input[j];
  				if (currentValue >= n && currentValue < m) {
  					m = currentValue;
  				}
  			}

  			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
  			// but guard against overflow
  			handledCPCountPlusOne = handledCPCount + 1;
  			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
  				error('overflow');
  			}

  			delta += (m - n) * handledCPCountPlusOne;
  			n = m;

  			for (j = 0; j < inputLength; ++j) {
  				currentValue = input[j];

  				if (currentValue < n && ++delta > maxInt) {
  					error('overflow');
  				}

  				if (currentValue == n) {
  					// Represent delta as a generalized variable-length integer
  					for (q = delta, k = base; /* no condition */; k += base) {
  						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
  						if (q < t) {
  							break;
  						}
  						qMinusT = q - t;
  						baseMinusT = base - t;
  						output.push(
  							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
  						);
  						q = floor(qMinusT / baseMinusT);
  					}

  					output.push(stringFromCharCode(digitToBasic(q, 0)));
  					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
  					delta = 0;
  					++handledCPCount;
  				}
  			}

  			++delta;
  			++n;

  		}
  		return output.join('');
  	}

  	/**
  	 * Converts a Punycode string representing a domain name or an email address
  	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  	 * it doesn't matter if you call it on a string that has already been
  	 * converted to Unicode.
  	 * @memberOf punycode
  	 * @param {String} input The Punycoded domain name or email address to
  	 * convert to Unicode.
  	 * @returns {String} The Unicode representation of the given Punycode
  	 * string.
  	 */
  	function toUnicode(input) {
  		return mapDomain(input, function(string) {
  			return regexPunycode.test(string)
  				? decode(string.slice(4).toLowerCase())
  				: string;
  		});
  	}

  	/**
  	 * Converts a Unicode string representing a domain name or an email address to
  	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
  	 * i.e. it doesn't matter if you call it with a domain that's already in
  	 * ASCII.
  	 * @memberOf punycode
  	 * @param {String} input The domain name or email address to convert, as a
  	 * Unicode string.
  	 * @returns {String} The Punycode representation of the given domain name or
  	 * email address.
  	 */
  	function toASCII(input) {
  		return mapDomain(input, function(string) {
  			return regexNonASCII.test(string)
  				? 'xn--' + encode(string)
  				: string;
  		});
  	}

  	/*--------------------------------------------------------------------------*/

  	/** Define the public API */
  	punycode = {
  		/**
  		 * A string representing the current Punycode.js version number.
  		 * @memberOf punycode
  		 * @type String
  		 */
  		'version': '1.3.2',
  		/**
  		 * An object of methods to convert from JavaScript's internal character
  		 * representation (UCS-2) to Unicode code points, and back.
  		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
  		 * @memberOf punycode
  		 * @type Object
  		 */
  		'ucs2': {
  			'decode': ucs2decode,
  			'encode': ucs2encode
  		},
  		'decode': decode,
  		'encode': encode,
  		'toASCII': toASCII,
  		'toUnicode': toUnicode
  	};

  	/** Expose `punycode` */
  	// Some AMD build optimizers, like r.js, check for specific condition patterns
  	// like the following:
  	if (freeExports && freeModule) {
  		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
  			freeModule.exports = punycode;
  		} else { // in Narwhal or RingoJS v0.7.0-
  			for (key in punycode) {
  				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
  			}
  		}
  	} else { // in Rhino or a web browser
  		root.punycode = punycode;
  	}

  }(commonjsGlobal));
  });

  var util = {
    isString: function(arg) {
      return typeof(arg) === 'string';
    },
    isObject: function(arg) {
      return typeof(arg) === 'object' && arg !== null;
    },
    isNull: function(arg) {
      return arg === null;
    },
    isNullOrUndefined: function(arg) {
      return arg == null;
    }
  };

  // Copyright Joyent, Inc. and other Node contributors.

  // If obj.hasOwnProperty has been overridden, then calling
  // obj.hasOwnProperty(prop) will break.
  // See: https://github.com/joyent/node/issues/1707
  function hasOwnProperty$1(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var decode = function(qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};

    if (typeof qs !== 'string' || qs.length === 0) {
      return obj;
    }

    var regexp = /\+/g;
    qs = qs.split(sep);

    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
      maxKeys = options.maxKeys;
    }

    var len = qs.length;
    // maxKeys <= 0 means that we should not limit keys count
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }

    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, '%20'),
          idx = x.indexOf(eq),
          kstr, vstr, k, v;

      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = '';
      }

      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);

      if (!hasOwnProperty$1(obj, k)) {
        obj[k] = v;
      } else if (Array.isArray(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }

    return obj;
  };

  // Copyright Joyent, Inc. and other Node contributors.

  var stringifyPrimitive = function(v) {
    switch (typeof v) {
      case 'string':
        return v;

      case 'boolean':
        return v ? 'true' : 'false';

      case 'number':
        return isFinite(v) ? v : '';

      default:
        return '';
    }
  };

  var encode = function(obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
      obj = undefined;
    }

    if (typeof obj === 'object') {
      return Object.keys(obj).map(function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (Array.isArray(obj[k])) {
          return obj[k].map(function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);

    }

    if (!name) return '';
    return encodeURIComponent(stringifyPrimitive(name)) + eq +
           encodeURIComponent(stringifyPrimitive(obj));
  };

  var querystring = createCommonjsModule(function (module, exports) {

  exports.decode = exports.parse = decode;
  exports.encode = exports.stringify = encode;
  });
  var querystring_1 = querystring.decode;
  var querystring_2 = querystring.parse;
  var querystring_3 = querystring.encode;
  var querystring_4 = querystring.stringify;

  var parse = urlParse;
  var resolve = urlResolve;
  var resolveObject = urlResolveObject;
  var format = urlFormat;

  var Url_1 = Url;

  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }

  // Reference: RFC 3986, RFC 1808, RFC 2396

  // define these here so at least they only have to be
  // compiled once on the first module load.
  var protocolPattern = /^([a-z0-9.+-]+:)/i,
      portPattern = /:[0-9]*$/,

      // Special case for a simple path URL
      simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

      // RFC 2396: characters reserved for delimiting URLs.
      // We actually just auto-escape these.
      delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

      // RFC 2396: characters not allowed for various reasons.
      unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

      // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
      autoEscape = ['\''].concat(unwise),
      // Characters that are never ever allowed in a hostname.
      // Note that any invalid chars are also handled, but these
      // are the ones that are *expected* to be seen, so we fast-path
      // them.
      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
      hostEndingChars = ['/', '?', '#'],
      hostnameMaxLen = 255,
      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
      // protocols that can allow "unsafe" and "unwise" chars.
      unsafeProtocol = {
        'javascript': true,
        'javascript:': true
      },
      // protocols that never have a hostname.
      hostlessProtocol = {
        'javascript': true,
        'javascript:': true
      },
      // protocols that always contain a // bit.
      slashedProtocol = {
        'http': true,
        'https': true,
        'ftp': true,
        'gopher': true,
        'file': true,
        'http:': true,
        'https:': true,
        'ftp:': true,
        'gopher:': true,
        'file:': true
      };

  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && util.isObject(url) && url instanceof Url) return url;

    var u = new Url;
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
  }

  Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
    if (!util.isString(url)) {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    }

    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    var queryIndex = url.indexOf('?'),
        splitter =
            (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
        uSplit = url.split(splitter),
        slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, '/');
    url = uSplit.join(splitter);

    var rest = url;

    // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"
    rest = rest.trim();

    if (!slashesDenoteHost && url.split('#').length === 1) {
      // Try fast path regexp
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.path = rest;
        this.href = rest;
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
          if (parseQueryString) {
            this.query = querystring.parse(this.search.substr(1));
          } else {
            this.query = this.search.substr(1);
          }
        } else if (parseQueryString) {
          this.search = '';
          this.query = {};
        }
        return this;
      }
    }

    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }

    // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === '//';
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }

    if (!hostlessProtocol[proto] &&
        (slashes || (proto && !slashedProtocol[proto]))) {

      // there's a hostname.
      // the first instance of /, ?, ;, or # ends the host.
      //
      // If there is an @ in the hostname, then non-host chars *are* allowed
      // to the left of the last @ sign, unless some host-ending character
      // comes *before* the @-sign.
      // URLs are obnoxious.
      //
      // ex:
      // http://a@b@c/ => user:a@b host:c
      // http://a@b?@c => user:a host:c path:/?@c

      // v0.12 TODO(isaacs): This is not quite how Chrome does things.
      // Review our test case against browsers more comprehensively.

      // find the first instance of any hostEndingChars
      var hostEnd = -1;
      for (var i = 0; i < hostEndingChars.length; i++) {
        var hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }

      // at this point, either we have an explicit point where the
      // auth portion cannot go past, or the last @ char is the decider.
      var auth, atSign;
      if (hostEnd === -1) {
        // atSign can be anywhere.
        atSign = rest.lastIndexOf('@');
      } else {
        // atSign must be in auth portion.
        // http://a@b/c@d => host:b auth:a path:/c@d
        atSign = rest.lastIndexOf('@', hostEnd);
      }

      // Now we have a portion which is definitely the auth.
      // Pull that off.
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = decodeURIComponent(auth);
      }

      // the host is the remaining to the left of the first non-host char
      hostEnd = -1;
      for (var i = 0; i < nonHostChars.length; i++) {
        var hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      // if we still have not hit it, then the entire thing is a host.
      if (hostEnd === -1)
        hostEnd = rest.length;

      this.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);

      // pull out port.
      this.parseHost();

      // we've indicated that there is a hostname,
      // so even if it's empty, it has to be present.
      this.hostname = this.hostname || '';

      // if hostname begins with [ and ends with ]
      // assume that it's an IPv6 address.
      var ipv6Hostname = this.hostname[0] === '[' &&
          this.hostname[this.hostname.length - 1] === ']';

      // validate a little.
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (var i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part) continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = '';
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                // we replace non-ASCII char with a temporary placeholder
                // we need this to make sure size of hostname is not
                // broken by replacing non-ASCII by nothing
                newpart += 'x';
              } else {
                newpart += part[j];
              }
            }
            // we test again with ASCII char only
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = '/' + notHost.join('.') + rest;
              }
              this.hostname = validParts.join('.');
              break;
            }
          }
        }
      }

      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = '';
      } else {
        // hostnames are always lower case.
        this.hostname = this.hostname.toLowerCase();
      }

      if (!ipv6Hostname) {
        // IDNA Support: Returns a punycoded representation of "domain".
        // It only converts parts of the domain name that
        // have non-ASCII characters, i.e. it doesn't matter if
        // you call it with a domain that already is ASCII-only.
        this.hostname = punycode.toASCII(this.hostname);
      }

      var p = this.port ? ':' + this.port : '';
      var h = this.hostname || '';
      this.host = h + p;
      this.href += this.host;

      // strip [ and ] from the hostname
      // the host field still retains them, though
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        if (rest[0] !== '/') {
          rest = '/' + rest;
        }
      }
    }

    // now rest is set to the post-host stuff.
    // chop off any delim chars.
    if (!unsafeProtocol[lowerProto]) {

      // First, make 100% sure that any "autoEscape" chars get
      // escaped, even if encodeURIComponent doesn't think they
      // need to be.
      for (var i = 0, l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        if (rest.indexOf(ae) === -1)
          continue;
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }


    // chop off from the tail first.
    var hash = rest.indexOf('#');
    if (hash !== -1) {
      // got a fragment string.
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf('?');
    if (qm !== -1) {
      this.search = rest.substr(qm);
      this.query = rest.substr(qm + 1);
      if (parseQueryString) {
        this.query = querystring.parse(this.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      // no query string, but parseQueryString still requested
      this.search = '';
      this.query = {};
    }
    if (rest) this.pathname = rest;
    if (slashedProtocol[lowerProto] &&
        this.hostname && !this.pathname) {
      this.pathname = '/';
    }

    //to support http.request
    if (this.pathname || this.search) {
      var p = this.pathname || '';
      var s = this.search || '';
      this.path = p + s;
    }

    // finally, reconstruct the href based on what has been validated.
    this.href = this.format();
    return this;
  };

  // format a parsed object into a url string
  function urlFormat(obj) {
    // ensure it's an object, and not a string url.
    // If it's an obj, this is a no-op.
    // this way, you can call url_format() on strings
    // to clean up potentially wonky urls.
    if (util.isString(obj)) obj = urlParse(obj);
    if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
    return obj.format();
  }

  Url.prototype.format = function() {
    var auth = this.auth || '';
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ':');
      auth += '@';
    }

    var protocol = this.protocol || '',
        pathname = this.pathname || '',
        hash = this.hash || '',
        host = false,
        query = '';

    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.indexOf(':') === -1 ?
          this.hostname :
          '[' + this.hostname + ']');
      if (this.port) {
        host += ':' + this.port;
      }
    }

    if (this.query &&
        util.isObject(this.query) &&
        Object.keys(this.query).length) {
      query = querystring.stringify(this.query);
    }

    var search = this.search || (query && ('?' + query)) || '';

    if (protocol && protocol.substr(-1) !== ':') protocol += ':';

    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
    // unless they had them to begin with.
    if (this.slashes ||
        (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = '//' + (host || '');
      if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
    } else if (!host) {
      host = '';
    }

    if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
    if (search && search.charAt(0) !== '?') search = '?' + search;

    pathname = pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
    search = search.replace('#', '%23');

    return protocol + host + pathname + search + hash;
  };

  function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
  }

  Url.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };

  function urlResolveObject(source, relative) {
    if (!source) return relative;
    return urlParse(source, false, true).resolveObject(relative);
  }

  Url.prototype.resolveObject = function(relative) {
    if (util.isString(relative)) {
      var rel = new Url();
      rel.parse(relative, false, true);
      relative = rel;
    }

    var result = new Url();
    var tkeys = Object.keys(this);
    for (var tk = 0; tk < tkeys.length; tk++) {
      var tkey = tkeys[tk];
      result[tkey] = this[tkey];
    }

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there's nothing left to do here.
    if (relative.href === '') {
      result.href = result.format();
      return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative.protocol) {
      // take everything except the protocol from relative
      var rkeys = Object.keys(relative);
      for (var rk = 0; rk < rkeys.length; rk++) {
        var rkey = rkeys[rk];
        if (rkey !== 'protocol')
          result[rkey] = relative[rkey];
      }

      //urlParse appends trailing / to urls like http://www.example.com
      if (slashedProtocol[result.protocol] &&
          result.hostname && !result.pathname) {
        result.path = result.pathname = '/';
      }

      result.href = result.format();
      return result;
    }

    if (relative.protocol && relative.protocol !== result.protocol) {
      // if it's a known url protocol, then changing
      // the protocol does weird things
      // first, if it's not file:, then we MUST have a host,
      // and if there was a path
      // to begin with, then we MUST have a path.
      // if it is file:, then the host is dropped,
      // because that's known to be hostless.
      // anything else is assumed to be absolute.
      if (!slashedProtocol[relative.protocol]) {
        var keys = Object.keys(relative);
        for (var v = 0; v < keys.length; v++) {
          var k = keys[v];
          result[k] = relative[k];
        }
        result.href = result.format();
        return result;
      }

      result.protocol = relative.protocol;
      if (!relative.host && !hostlessProtocol[relative.protocol]) {
        var relPath = (relative.pathname || '').split('/');
        while (relPath.length && !(relative.host = relPath.shift()));
        if (!relative.host) relative.host = '';
        if (!relative.hostname) relative.hostname = '';
        if (relPath[0] !== '') relPath.unshift('');
        if (relPath.length < 2) relPath.unshift('');
        result.pathname = relPath.join('/');
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.query = relative.query;
      result.host = relative.host || '';
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result.port = relative.port;
      // to support http.request
      if (result.pathname || result.search) {
        var p = result.pathname || '';
        var s = result.search || '';
        result.path = p + s;
      }
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    }

    var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
        isRelAbs = (
            relative.host ||
            relative.pathname && relative.pathname.charAt(0) === '/'
        ),
        mustEndAbs = (isRelAbs || isSourceAbs ||
                      (result.host && relative.pathname)),
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        relPath = relative.pathname && relative.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];

    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
      result.hostname = '';
      result.port = null;
      if (result.host) {
        if (srcPath[0] === '') srcPath[0] = result.host;
        else srcPath.unshift(result.host);
      }
      result.host = '';
      if (relative.protocol) {
        relative.hostname = null;
        relative.port = null;
        if (relative.host) {
          if (relPath[0] === '') relPath[0] = relative.host;
          else relPath.unshift(relative.host);
        }
        relative.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
    }

    if (isRelAbs) {
      // it's absolute.
      result.host = (relative.host || relative.host === '') ?
                    relative.host : result.host;
      result.hostname = (relative.hostname || relative.hostname === '') ?
                        relative.hostname : result.hostname;
      result.search = relative.search;
      result.query = relative.query;
      srcPath = relPath;
      // fall through to the dot-handling below.
    } else if (relPath.length) {
      // it's relative
      // throw away the existing file, and take the new path instead.
      if (!srcPath) srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
      result.query = relative.query;
    } else if (!util.isNullOrUndefined(relative.search)) {
      // just pull out the search.
      // like href='?foo'.
      // Put this after the other two cases because it simplifies the booleans
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ?
                         result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result.query = relative.query;
      //to support http.request
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') +
                      (result.search ? result.search : '');
      }
      result.href = result.format();
      return result;
    }

    if (!srcPath.length) {
      // no path at all.  easy.
      // we've already handled the other stuff above.
      result.pathname = null;
      //to support http.request
      if (result.search) {
        result.path = '/' + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (
        (result.host || relative.host || srcPath.length > 1) &&
        (last === '.' || last === '..') || last === '');

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
      last = srcPath[i];
      if (last === '.') {
        srcPath.splice(i, 1);
      } else if (last === '..') {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
      for (; up--; up) {
        srcPath.unshift('..');
      }
    }

    if (mustEndAbs && srcPath[0] !== '' &&
        (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
      srcPath.unshift('');
    }

    if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
      srcPath.push('');
    }

    var isAbsolute = srcPath[0] === '' ||
        (srcPath[0] && srcPath[0].charAt(0) === '/');

    // put the host back
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? '' :
                                      srcPath.length ? srcPath.shift() : '';
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    mustEndAbs = mustEndAbs || (result.host && srcPath.length);

    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift('');
    }

    if (!srcPath.length) {
      result.pathname = null;
      result.path = null;
    } else {
      result.pathname = srcPath.join('/');
    }

    //to support request.http
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  };

  Url.prototype.parseHost = function() {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ':') {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) this.hostname = host;
  };

  var url = {
  	parse: parse,
  	resolve: resolve,
  	resolveObject: resolveObject,
  	format: format,
  	Url: Url_1
  };

  var keys = createCommonjsModule(function (module, exports) {
  exports = module.exports = typeof Object.keys === 'function'
    ? Object.keys : shim;

  exports.shim = shim;
  function shim (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
  }
  });
  var keys_1 = keys.shim;

  var is_arguments = createCommonjsModule(function (module, exports) {
  var supportsArgumentsClass = (function(){
    return Object.prototype.toString.call(arguments)
  })() == '[object Arguments]';

  exports = module.exports = supportsArgumentsClass ? supported : unsupported;

  exports.supported = supported;
  function supported(object) {
    return Object.prototype.toString.call(object) == '[object Arguments]';
  }
  exports.unsupported = unsupported;
  function unsupported(object){
    return object &&
      typeof object == 'object' &&
      typeof object.length == 'number' &&
      Object.prototype.hasOwnProperty.call(object, 'callee') &&
      !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
      false;
  }});
  var is_arguments_1 = is_arguments.supported;
  var is_arguments_2 = is_arguments.unsupported;

  var deepEqual_1 = createCommonjsModule(function (module) {
  var pSlice = Array.prototype.slice;



  var deepEqual = module.exports = function (actual, expected, opts) {
    if (!opts) opts = {};
    // 7.1. All identical values are equivalent, as determined by ===.
    if (actual === expected) {
      return true;

    } else if (actual instanceof Date && expected instanceof Date) {
      return actual.getTime() === expected.getTime();

    // 7.3. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
    } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
      return opts.strict ? actual === expected : actual == expected;

    // 7.4. For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
    } else {
      return objEquiv(actual, expected, opts);
    }
  };

  function isUndefinedOrNull(value) {
    return value === null || value === undefined;
  }

  function isBuffer (x) {
    if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
    if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
      return false;
    }
    if (x.length > 0 && typeof x[0] !== 'number') return false;
    return true;
  }

  function objEquiv(a, b, opts) {
    var i, key;
    if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
      return false;
    // an identical 'prototype' property.
    if (a.prototype !== b.prototype) return false;
    //~~~I've managed to break Object.keys through screwy arguments passing.
    //   Converting to array solves the problem.
    if (is_arguments(a)) {
      if (!is_arguments(b)) {
        return false;
      }
      a = pSlice.call(a);
      b = pSlice.call(b);
      return deepEqual(a, b, opts);
    }
    if (isBuffer(a)) {
      if (!isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) return false;
      for (i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }
    try {
      var ka = keys(a),
          kb = keys(b);
    } catch (e) {//happens when one is a string literal and the other isn't
      return false;
    }
    // having the same number of owned properties (keys incorporates
    // hasOwnProperty)
    if (ka.length != kb.length)
      return false;
    //the same set of keys (although not necessarily the same order),
    ka.sort();
    kb.sort();
    //~~~cheap key test
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i])
        return false;
    }
    //equivalent values for every corresponding key, and
    //~~~possibly expensive deep test
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!deepEqual(a[key], b[key], opts)) return false;
    }
    return typeof a === typeof b;
  }
  });

  /**
   * Parses the given URI and returns the properties
   * elligible for comparison. Leaves out raw properties like "path"
   * that cannot be compared due to struct query parameters order.
   * @param {string} uri
   * @returns {Object<string, string | number>}
   */
  const parseURI = (uri) => {
    const { pathname, port, hash, query } = url.parse(uri, true);
    return {
      pathname,
      port,
      hash,
      query
    };
  };

  const validateURI = (expected, actual) => {
    const values = {
      expected: expected.uri,
      actual: actual.uri
    };

    // Parses URI to perform a correct comparison:
    // - literal comparison of pathname
    // - order-insensitive comparison of query parameters
    const parsedExpected = parseURI(values.expected);
    const parsedActual = parseURI(values.actual);

    // Note the different order of arguments between
    // "validateURI" and "deepEqual".
    const valid = deepEqual_1(parsedActual, parsedExpected);
    const errors = [];

    if (!valid) {
      errors.push({
        message: `Expected URI '${values.expected}', but got '${values.actual}'.`
      });
    }

    return {
      valid,
      kind: 'text',
      values,
      errors
    };
  };

  var validateURI_1 = { validateURI };

  /**
   * Validates given real and expected status codes.
   * @param {Object} real
   * @param {number} expected
   */
  function validateStatusCode(expected, actual) {
    const values = {
      expected: expected.statusCode,
      actual: actual.statusCode
    };
    const valid = values.actual === values.expected;
    const errors = [];

    if (!valid) {
      errors.push({
        message: `Expected status code '${values.expected}', but got '${values.actual}'.`
      });
    }

    return {
      valid,
      kind: 'text',
      values,
      errors
    };
  }

  var validateStatusCode_1 = { validateStatusCode };

  var clone_1 = createCommonjsModule(function (module) {
  var clone = (function() {

  function _instanceof(obj, type) {
    return type != null && obj instanceof type;
  }

  var nativeMap;
  try {
    nativeMap = Map;
  } catch(_) {
    // maybe a reference error because no `Map`. Give it a dummy value that no
    // value will ever be an instanceof.
    nativeMap = function() {};
  }

  var nativeSet;
  try {
    nativeSet = Set;
  } catch(_) {
    nativeSet = function() {};
  }

  var nativePromise;
  try {
    nativePromise = Promise;
  } catch(_) {
    nativePromise = function() {};
  }

  /**
   * Clones (copies) an Object using deep copying.
   *
   * This function supports circular references by default, but if you are certain
   * there are no circular references in your object, you can save some CPU time
   * by calling clone(obj, false).
   *
   * Caution: if `circular` is false and `parent` contains circular references,
   * your program may enter an infinite loop and crash.
   *
   * @param `parent` - the object to be cloned
   * @param `circular` - set to true if the object to be cloned may contain
   *    circular references. (optional - true by default)
   * @param `depth` - set to a number if the object is only to be cloned to
   *    a particular depth. (optional - defaults to Infinity)
   * @param `prototype` - sets the prototype to be used when cloning an object.
   *    (optional - defaults to parent prototype).
   * @param `includeNonEnumerable` - set to true if the non-enumerable properties
   *    should be cloned as well. Non-enumerable properties on the prototype
   *    chain will be ignored. (optional - false by default)
  */
  function clone(parent, circular, depth, prototype, includeNonEnumerable) {
    if (typeof circular === 'object') {
      depth = circular.depth;
      prototype = circular.prototype;
      includeNonEnumerable = circular.includeNonEnumerable;
      circular = circular.circular;
    }
    // maintain two arrays for circular references, where corresponding parents
    // and children have the same index
    var allParents = [];
    var allChildren = [];

    var useBuffer = typeof Buffer != 'undefined';

    if (typeof circular == 'undefined')
      circular = true;

    if (typeof depth == 'undefined')
      depth = Infinity;

    // recurse this function so we don't reset allParents and allChildren
    function _clone(parent, depth) {
      // cloning null always returns null
      if (parent === null)
        return null;

      if (depth === 0)
        return parent;

      var child;
      var proto;
      if (typeof parent != 'object') {
        return parent;
      }

      if (_instanceof(parent, nativeMap)) {
        child = new nativeMap();
      } else if (_instanceof(parent, nativeSet)) {
        child = new nativeSet();
      } else if (_instanceof(parent, nativePromise)) {
        child = new nativePromise(function (resolve, reject) {
          parent.then(function(value) {
            resolve(_clone(value, depth - 1));
          }, function(err) {
            reject(_clone(err, depth - 1));
          });
        });
      } else if (clone.__isArray(parent)) {
        child = [];
      } else if (clone.__isRegExp(parent)) {
        child = new RegExp(parent.source, __getRegExpFlags(parent));
        if (parent.lastIndex) child.lastIndex = parent.lastIndex;
      } else if (clone.__isDate(parent)) {
        child = new Date(parent.getTime());
      } else if (useBuffer && Buffer.isBuffer(parent)) {
        if (Buffer.allocUnsafe) {
          // Node.js >= 4.5.0
          child = Buffer.allocUnsafe(parent.length);
        } else {
          // Older Node.js versions
          child = new Buffer(parent.length);
        }
        parent.copy(child);
        return child;
      } else if (_instanceof(parent, Error)) {
        child = Object.create(parent);
      } else {
        if (typeof prototype == 'undefined') {
          proto = Object.getPrototypeOf(parent);
          child = Object.create(proto);
        }
        else {
          child = Object.create(prototype);
          proto = prototype;
        }
      }

      if (circular) {
        var index = allParents.indexOf(parent);

        if (index != -1) {
          return allChildren[index];
        }
        allParents.push(parent);
        allChildren.push(child);
      }

      if (_instanceof(parent, nativeMap)) {
        parent.forEach(function(value, key) {
          var keyChild = _clone(key, depth - 1);
          var valueChild = _clone(value, depth - 1);
          child.set(keyChild, valueChild);
        });
      }
      if (_instanceof(parent, nativeSet)) {
        parent.forEach(function(value) {
          var entryChild = _clone(value, depth - 1);
          child.add(entryChild);
        });
      }

      for (var i in parent) {
        var attrs;
        if (proto) {
          attrs = Object.getOwnPropertyDescriptor(proto, i);
        }

        if (attrs && attrs.set == null) {
          continue;
        }
        child[i] = _clone(parent[i], depth - 1);
      }

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(parent);
        for (var i = 0; i < symbols.length; i++) {
          // Don't need to worry about cloning a symbol because it is a primitive,
          // like a number or string.
          var symbol = symbols[i];
          var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
          if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
            continue;
          }
          child[symbol] = _clone(parent[symbol], depth - 1);
          if (!descriptor.enumerable) {
            Object.defineProperty(child, symbol, {
              enumerable: false
            });
          }
        }
      }

      if (includeNonEnumerable) {
        var allPropertyNames = Object.getOwnPropertyNames(parent);
        for (var i = 0; i < allPropertyNames.length; i++) {
          var propertyName = allPropertyNames[i];
          var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
          if (descriptor && descriptor.enumerable) {
            continue;
          }
          child[propertyName] = _clone(parent[propertyName], depth - 1);
          Object.defineProperty(child, propertyName, {
            enumerable: false
          });
        }
      }

      return child;
    }

    return _clone(parent, depth);
  }

  /**
   * Simple flat clone using prototype, accepts only objects, usefull for property
   * override on FLAT configuration object (no nested props).
   *
   * USE WITH CAUTION! This may not behave as you wish if you do not know how this
   * works.
   */
  clone.clonePrototype = function clonePrototype(parent) {
    if (parent === null)
      return null;

    var c = function () {};
    c.prototype = parent;
    return new c();
  };

  // private utility functions

  function __objToStr(o) {
    return Object.prototype.toString.call(o);
  }
  clone.__objToStr = __objToStr;

  function __isDate(o) {
    return typeof o === 'object' && __objToStr(o) === '[object Date]';
  }
  clone.__isDate = __isDate;

  function __isArray(o) {
    return typeof o === 'object' && __objToStr(o) === '[object Array]';
  }
  clone.__isArray = __isArray;

  function __isRegExp(o) {
    return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
  }
  clone.__isRegExp = __isRegExp;

  function __getRegExpFlags(re) {
    var flags = '';
    if (re.global) flags += 'g';
    if (re.ignoreCase) flags += 'i';
    if (re.multiline) flags += 'm';
    return flags;
  }
  clone.__getRegExpFlags = __getRegExpFlags;

  return clone;
  })();

  if ( module.exports) {
    module.exports = clone;
  }
  });

  class MalformedDataError extends Error {}
  class DataNotJsonParsableError extends MalformedDataError {}
  class DataNotStringError extends MalformedDataError {}
  class MalformedSchemaError extends Error {}
  class SchemaNotJsonParsableError extends MalformedSchemaError {}
  class UnknownValidatorError extends Error {}
  class NotValidatableError extends Error {}
  class NotEnoughDataError extends Error {}
  class JsonSchemaNotValid extends Error {}

  var errors = {
    DataNotJsonParsableError,
    SchemaNotJsonParsableError,
    MalformedSchemaError,
    MalformedDataError,
    UnknownValidatorError,
    DataNotStringError,
    NotValidatableError,
    NotEnoughDataError,
    JsonSchemaNotValid,
  };

  var amanda = createCommonjsModule(function (module) {
  (function() {

    /**
     * Engines
     * --------------------
     */
    var engines = {};

  /**
   * DetectType
   *
   * @param {object} input
   */
  var detectType = function(input) {
    return typeof input;
  };

  /**
   * Each
   *
   * Applies an iterator function to each item in an array or an object, in series.
   *
   * @param {object} list
   * @param {function} iterator
   * @param {function} callback
   */
  var each = function(list, iterator, callback) {

    /**
     * SyncEach
     *
     * @param {object} list
     * @param {function} iterator
     */
    var syncEach = function(list, iterator) {

      // If the list is an array
      if (isArray(list) && !isEmpty(list)) {
        for (var i = 0, len = list.length; i < len; i++) {
          iterator.apply(list, [i, list[i]]);
        }
      }

      // If the list is an object
      if (isObject(list) && !isEmpty(list)) {
        for (var key in list) {
          if (list.hasOwnProperty(key)) {
            iterator.apply(list, [key, list[key]]);
          }
        }
      }

    };

    /**
     * AsyncEach
     * @param {object} list
     * @param {function} iterator
     * @param {function} callback
     */
      var asyncEach = function(list, iterator, callback) {

        var finished    = 0;
        var started     = 0;
        var hasCalled   = false;
        var mayCallback = false;

        var tryCallback = function() {
          if (mayCallback && finished == started) {
            // finished all functions, celebrate!
              return callback();
          }
        };

        /**
         * AddToQueue
         *
         * @param {string} key
         * @param {string|object} value
         */
        var addToQueue = function(key, value) {
          var cb = function(error) {
            // return early if already called back
            if (hasCalled) return;

            if (error) {
              // if error, fail fast
              hasCalled = true;
              return callback(error);

            }

            finished++;
              return tryCallback();

          };

          // execute right away
          started++;
          return iterator(key, value, cb);
        };


        // If the list is an array
        if (isArray(list) && !isEmpty(list)) {
          for (var i = 0, len = list.length; i < len; i++) {
            addToQueue(i, list[i]);
          }

        // If the list is an object
        } else if (isObject(list) && !isEmpty(list)) {
          for (var key in list) {
            if (list.hasOwnProperty(key)) {
              addToQueue(key, list[key]);
            }
          }

        // If the list is not an array or an object
        } else {
          return callback();
        }

        // Done adding items. Allow callback to fire
        mayCallback = true;
        return tryCallback();
      };

      if (typeof callback === 'undefined') {
        return syncEach.apply(this, arguments);
      } else {
        return asyncEach.apply(this, arguments);
      }

    };


  /**
   * Every
   *
   * @param {object} arr
   * @param {function} iterator
   */
  var every = function(arr, iterator) {
    return Array.prototype.every.apply(arr, [iterator]);
  };

  /**
   * Filter
   *
   * @param {object} arr
   * @param {function} iterator
   */
  var filter = function(arr, iterator, context) {
    return Array.prototype.filter.apply(arr, [iterator, context || this]);
  };

  /**
   * HasProperty
   *
   * @param {object} input
   */
  var hasProperty = function(obj, property) {
    return Object.prototype.hasOwnProperty.apply(obj, [property]);
  };

  /**
   * IsArray
   *
   * Returns true if the passed-in object is an array.
   *
   * @param {object} input
   */
  var isArray = function(input) {
    return Object.prototype.toString.call(input) === '[object Array]';
  };

  /**
   * IsBoolean
   *
   * @param {object} input
   */
  var isBoolean = function(input) {
    return typeof input === 'boolean';
  };

  /**
   * IsDefined
   *
   * @param {object} input
   */
  var isDefined = function(input) {
    return typeof input !== 'undefined';
  };

  /**
   * IsEmpty
   *  
   * Returns true if the passed-in object is empty.
   *
   * @param {object} input
   */
  var isEmpty = function(input) {

    if (isNumber(input)) {
      return false;
    }

    if (input === null) {
      return true;
    }

    // If the passed-in object is an array or a string
    if (isArray(input) || typeof input === 'string') {
      return input.length === 0;
    }

    // If the passed-in object is an object
    if (isObject(input)) {
      for (var key in input) {
        if (hasOwnProperty.call(input, key)) return false;
      }
    }

    return true;

  };

  /**
   * IsEqual
   *
   * @param {object} obj1
   * @param {object} obj2
   */
  var isEqual = function(obj1, obj2) {

    /**
     * Arrays
     */
    if (isArray(obj1)) {

      if (obj1.length !== obj2.length) {
        return false;
      }

      return every(obj1, function(value, index, context) {
        return obj2[index] === value;
      });

    }

    /**
     * Objects
     */
    if (isObject(obj1)) {

      var keys1 = keys(obj1),
          keys2 = keys(obj2);

      if (!isEqual(keys1, keys2)) {
        return false;
      }

      for (key in obj1) {
        if (!obj2[key] || obj1[key] !== obj2[key]) {
          return false;
        }
      }

      return true;

    }

    return false;

  };

  /**
   * IsFunction
   *
   * @param {object} input
   */
  var isFunction = function(input) {
    return typeof input === 'function';
  };

  /**
   * IsInteger
   *
   * @param {object} input
   */
  var isInteger = function(input) {
    return isNumber(input) && input % 1 === 0;
  };

  /**
   * IsNull
   *
   * @param {object} input
   */
  var isNull = function(input) {
    return input === null;
  };

  /**
   * IsNumber
   *
   * @param {object} input
   */
  var isNumber = function(input) {
    return typeof input === 'number';
  };

  /**
   * IsObject
   *
   * Returns true if the passed-in object is an object.
   *
   * @param {object} input
   */
  var isObject = function(input) {
    return Object.prototype.toString.call(input) === '[object Object]';
  };

  /**
   * IsString
   *
   * @param {object} input
   */
  var isString = function(input) {
    return typeof input === 'string';
  };

  /**
   * IsUndefined
   *
   * @param {object} input
   */
  var isUndefined = function(input) {
    return typeof input === 'undefined';
  };

  /**
   * Keys
   *
   * @param {object} obj
   */
  var keys = function(obj) {
    return Object.keys(obj);
  };

  /**
   * Merge
   *
   * Copy all of the properties in the source objects over to the destination object.
   *
   * @param {object} obj1
   * @param {object} obj2
   */
  var merge = function(obj1, obj2) {
    for (var key in obj2) {
      if (obj2.hasOwnProperty(key) && !obj1.hasOwnProperty(key)) {
        obj1[key] = obj2[key];
      }
    }
    return obj1;
  };

  /**
   * Pluck
   *
   * Extracts a list of property values.
   *
   * @param {object} list
   * @param {string} propertyName
   */
  var pluck = function(list, propertyName) {
    var output = [];
    for (var i = 0, len = list.length; i < len; i++) {
      var property = list[i][propertyName];
      if (output.indexOf(property) === -1) {
        output.push(property);
      }
    }
    return output;
  };

  /**
   * ReturnTrue
   */
  var returnTrue = function() {
    return true;
  };

  (function() {

  /**
   * Validation
   *
   * @constructor
   * @param {object} options
   */
  var Validation = function(options) {

    // Save a reference to the this
    var self = this;

    var defaultOptions = {
      singleError: true,
      messages: errorMessages,
      cache: false
    };

    each(defaultOptions, function(key, value) {

      if (isObject(value) && options[key]) {
        self[key] = merge(options[key], defaultOptions[key]);

      } else if (isObject(value) && !options[key]) {
        self[key] = merge ({}, defaultOptions[key]);

      } else {
        self[key] = (isDefined(options[key])) ? options[key] : defaultOptions[key];
      }

    });

    this.errors = new ValidationError(this);

  };

  /**
   * Attributes
   * --------------------
   */
  Validation.prototype.attributes = {};

  /**
   * AddAttribute
   *
   * @param {string} attributeName
   * @param {function} attributeFn
   */
  Validation.prototype.addAttribute = function(attributeName, attributeFn) {
    return Validation.prototype.attributes[attributeName] = attributeFn;
  };

  /**
   * AddAttributeConstructor
   *
   * @param {string} attributeName
   * @param {function} attributeConstructor
   */
  Validation.prototype.addAttributeConstructor = function(attributeName, attributeConstructor) {
    return Validation.prototype.attributes[attributeName] = attributeConstructor();
  };

  /**
   * AdditionalProperties
   */
  var additionalPropertiesAttribute = function additionalProperties(property, propertyValue, attributeValue, propertyAttributes, callback) {

    var self = this;

    /**
     * {
     *   additionalProperties: true,
     *   ...
     * }
     */
    if (attributeValue === true) {
      return callback();
    }

    // Filter the forbidden properties
    var propertyKeys = keys(propertyValue);
    var forbiddenProperties = filter(propertyKeys, function(key) {
      return !propertyAttributes.properties[key];
    });

    if (isEmpty(forbiddenProperties)) {
      return callback();
    }

    /**
     * {
     *   additionalProperties: false,
     *   ...
     * }
     */
    if (attributeValue === false) {

      forbiddenProperties.forEach(function(forbiddenProperty) {
        this.addError({
          property: this.joinPath(property, forbiddenProperty),
          propertyValue: propertyValue[forbiddenProperty]
        });
      }, this);

      return callback();

    }

    /**
     * {
     *   additionalProperties: {
     *     type: 'string',
     *     ...
     *   },
     *   ...
     * }
     */
    if (isObject(attributeValue)) {
      return each(forbiddenProperties, function(index, key, callback) {
        return self.validateSchema(
          propertyValue[key],
          attributeValue,
          property + key,
          callback
        );
      }, callback);
    }

  };

  // Export
  Validation.prototype.addAttribute('additionalProperties', additionalPropertiesAttribute);

  /**
   * DivisibleBy
   */
  var divisibleByAttribute = function divisibleBy(property, propertyValue, attributeValue, propertyAttributes, callback) {

    if (attributeValue === 0) {
      this.addError('The value of this attribute should not be 0.');
      return callback();
    }

    if (isNumber(propertyValue) && (propertyValue % attributeValue !== 0)) {
      this.addError();
    }

    return callback();

  };

  // Export
  Validation.prototype.addAttribute('divisibleBy', divisibleByAttribute);

  /**
   * Enum
   */
  var enumAttribute = function(property, propertyValue, attributeValue, propertyAttributes, callback) {

    if (attributeValue.indexOf(propertyValue) === -1) {
      this.addError();
    }

    return callback();

  };

  // Export
  Validation.prototype.addAttribute('enum', enumAttribute);

  /**
   * Except
   */
  var exceptAttribute = function except(property, propertyValue, attributeValue, propertyAttributes, callback) {

    if (attributeValue.indexOf(propertyValue) !== -1) {
      this.addError();
    }

    return callback();

  };

  // Export
  Validation.prototype.addAttribute('except', exceptAttribute);

  /**
   * Format
   */
  Validation.prototype.addAttributeConstructor('format', function formatConstructor() {

    /**
     * Formats
     */
    var formats = {

      /**
       * date-time
       *
       * This should be a date in ISO 8601 format of YYYY-MM-DDThh:mm:ssZ in UTC
       * time or with the timezone suffix.
       */
      'date-time': {
        type: 'string',
        pattern: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{1,})?([\-\+]\d{2}:\d{2}|Z)?$/
      },

      /**
       * date
       *
       * This should be a date in the format of YYYY-MM-DD. It is recommended that you
       * use the "date-time" format instead of "date" unless you need to transfer only the date part.
       */
      date: function(input) {
        if (isString(input)) {
          return input.match(/^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/);
        }
        return Object.prototype.toString.call(input) === '[object Date]';
      },

      /**
       * time
       *
       * This should be a time in the format of hh:mm:ss.
       */
      'time': {
        type: 'string',
        pattern: /^\d{2}:\d{2}:\d{2}$/
      },

      /**
       * utc-milisec
       *
       * This should be the difference, measured in milliseconds, between the specified
       * time and midnight, 00:00 of January 1, 1970 UTC.  The value
       * should be a number (integer or float).
       */
      'utc-milisec': {
        type: 'number'
      },

      /**
       * regex
       *
       * This should be a time in the format of hh:mm:ss.
       */
      regex: function(input) {
        return input && input.test && input.exec;
      },

      /**
       * color
       *
       * This is a CSS color (like "#FF0000" or "red"), based on CSS 2.1.
       */
      'color': {
        type: 'string'
      },

      /**
       * style
       *
       * This is a CSS style definition (like "color: red; background-color:#FFF"), based on CSS 2.1.
       */
      'style': {
        type: 'string'
      },

      /**
       * phone
       *
       * This should be a phone number.
       */
      'phone': {
        type: 'number'
      },

      /**
       * uri
       *
       * This value should be a URI.
       */
      'uri': {
        type: 'string',
        pattern: /^[^\s]+$/
      },

      /**
       * email
       *
       * This should be an email address.
       */
      'email': {
        type: 'string',
        pattern: /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/
      },

      /**
       * ip-address
       *
       * This should be an ip version 4 address.
       */
      'ip-address': {
        type: 'string',
        pattern: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
      },

      /**
       * ipv6
       *
       * This should be an ip version 6 address.
       */
      'ipv6': {
        type: 'string',
        pattern: /(?:(?:[a-f\d]{1,4}:)*(?:[a-f\d]{1,4}|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})|(?:(?:[a-f\d]{1,4}:)*[a-f\d]{1,4})?::(?:(?:[a-f\d]{1,4}:)*(?:[a-f\d]{1,4}|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))?)/
      },

      /**
       * host-name
       *
       * This should be a host-name.
       */
      'host-name': {
        type: 'string'
      }

    };

    /**
     * CustomFormats
     * --------------------
     */
    formats.alpha = {
      required: true,
      type: 'string',
      pattern: /^[a-zA-Z]+$/
    };

    formats.alphanumeric = {
      required: true,
      type: ['string', 'number'],
      pattern: /^[a-zA-Z0-9]+$/
    };

    formats.decimal = function(input) {
      if (!isNumber(input)) return false;
      return (input + '').match(/^[0-9]+(\.[0-9]{1,2})?$/);
    };

    formats.percentage = {
      required: true,
      type: ['string', 'number'],
      pattern: /^-?[0-9]{0,2}(\.[0-9]{1,2})?$|^-?(100)(\.[0]{1,2})?$/,
      minimum: -100,
      maximum: 100
    };

    formats.port = {
      required: true,
      type: ['string', 'number'],
      pattern: /\:\d+/
    };

    /**
     * Aliases
     * --------------------
     */
    var aliases = {
      url: 'uri',
      ip: 'ip-address',
      ipv4: 'ip-address',
      host: 'host-name',
      hostName: 'host-name'
    };

    // Apply aliases
    each(aliases, function(alias, format) {
      formats[alias] = formats[format];
    });

    // Export
    return function format(property, propertyValue, attributeValue, propertyAttributes, callback) {

      /**
       * {
       *   format: {
       *     type: 'string',
       *     pattern: /abc/
       *     ...
       *   }
       *   ...
       * }
       */
      if (isObject(attributeValue)) {
        return this.validateProperty(property, propertyValue, attributeValue, callback);
      }

      /**
       * {
       *   format: 'lorem ipsum dolor',
       *   ...
       * }
       */
      if (isString(attributeValue) && !hasProperty(formats, attributeValue)) {
        this.addError('The format ' + attributeValue + ' is not supported.');
        return callback();
      }

      /**
       * {
       *   format: 'phone',
       *   ...
       * }
       */
      if (isString(attributeValue)) {

        var fn = formats[attributeValue];

        if (isFunction(fn)) {
          var noError = fn(propertyValue);
          if (!noError) {
            this.addError();
          }
          return callback();
        }

        if (isObject(fn)) {
          return this.validateProperty(property, propertyValue, fn, callback);
        }

      }

    };

  });


  /**
   * Length
   */
  var lengthAttribute = function length(property, propertyValue, attributeValue, propertyAttributes, callback) {

    if (isString(propertyValue) && propertyValue.length !== attributeValue) {
      this.addError();
    }

    return callback();

  };

  // Export
  Validation.prototype.addAttribute('length', lengthAttribute);

  /**
   * Maximum
   */
  var maximumAttribute = function maximum(property, propertyValue, attributeValue, propertyAttributes, callback) {

    if (isNumber(propertyValue)) {
      if ((propertyAttributes.exclusiveMaximum && propertyValue >= attributeValue) || (propertyValue > attributeValue)) {
        this.addError();
      }
    }

    return callback();

  };

  // Export
  Validation.prototype.addAttribute('maximum', maximumAttribute);

  /**
   * MaxItems
   */
  var maxItemsAttribute = function maxItems(property, propertyValue, attributeValue, propertyAttributes, callback) {

    if (isArray(propertyValue) && propertyValue.length > attributeValue) {
      this.addError();
    }

    return callback();

  };

  // Export
  Validation.prototype.addAttribute('maxItems', maxItemsAttribute);

  /**
   * MaxLength
   */
  var maxLengthAttribute = function maxLength(property, propertyValue, attributeValue, propertyAttributes, callback) {

    if (isString(propertyValue) && propertyValue.length > attributeValue) {
      this.addError();
    }

    return callback();

  };

  // Export
  Validation.prototype.addAttribute('maxLength', maxLengthAttribute);

  /**
   * Minimum
   */
  var minimumAttribute = function minimum(property, propertyValue, attributeValue, propertyAttributes, callback) {

    if (isNumber(propertyValue)) {
      if ((propertyAttributes.exclusiveMinimum && propertyValue <= attributeValue) || (propertyValue < attributeValue)) {
        this.addError();
      }
    }

    return callback();

  };

  // Export
  Validation.prototype.addAttribute('minimum', minimumAttribute);


  /**
   * MinItems
   */
  var minItems = function minItems(property, propertyValue, attributeValue, propertyAttributes, callback) {

    if (isArray(propertyValue) && propertyValue.length < attributeValue) {
      this.addError();
    }

    return callback();

  };

  // Export
  Validation.prototype.addAttribute('minItems', minItems);

  /**
   * MinLength
   */
  var minLengthAttribute = function minLength(property, propertyValue, attributeValue, propertyAttributes, callback) {

    if (isString(propertyValue) && propertyValue.length < attributeValue) {
      this.addError();
    }

    return callback();

  };

  // Export
  Validation.prototype.addAttribute('minLength', minLengthAttribute);

  /**
   * Pattern
   */
  var patternAttribute = function pattern(property, propertyValue, attributeValue, propertyAttributes, callback) {

    if (isString(propertyValue) && !propertyValue.match(attributeValue)) {
      this.addError();
    }

    return callback();

  };

  // Export
  Validation.prototype.addAttribute('pattern', patternAttribute);

  (function() {

    /**
     * PatternProperties
     */
    var attribute = function patternProperties(property, propertyValue, attributeValue, propertyAttributes, callback) {

      // Saves a reference to this
      var self = this;

      // Skip
      if (isEmpty(attributeValue)) {
        return callback();
      }

      var matches = {};
      var patterns = keys(attributeValue);

      each(propertyValue, function(key, value) {

        each(patterns, function(index, pattern) {
          if (key.match(new RegExp(pattern))) {
            matches[key] = attributeValue[pattern];
          }
        });

      });

      if (isEmpty(matches)) {
        return callback();
      }

      each(matches, function(propertyName, propertySchema, callback) {
        return self.validateSchema(
          propertyValue[propertyName],
          propertySchema,
          self.joinPath(property, propertyName),
          callback
        );
      }, callback);

    };

    // Export
    Validation.prototype.addAttribute('patternProperties', attribute);

  }());

  /**
   * Required
   */
  var requiredAttribute = function required(property, propertyValue, attributeValue, propertyAttributes, callback) {

    if (attributeValue) {

      var undefinedCondition = isUndefined(propertyValue);

      if (undefinedCondition) {
        this.addError();
      }

    }

    return callback();

  };

  // Export
  Validation.prototype.addAttribute('required', requiredAttribute);


  /**
   * Type
   */
  var typeConstructor = function typeConstructor() {

    /**
     * Types
     */
    var types = {
      'string': isString,
      'number': isNumber,
      'function': isFunction,
      'boolean': isBoolean,
      'object': isObject,
      'array': isArray,
      'integer': isInteger,
      'int': isInteger,
      'null': isNull,
      'any': returnTrue
    };

    // Export
    return function type(property, propertyValue, attributeValue, propertyAttributes, callback) {

      /**
       * {
       *   type: ['string', 'number']
       * }
       */
      if (isArray(attributeValue)) {

        var typesSupported;

        typesSupported = every(attributeValue, function(type) {
          return hasProperty(types, type);
        });

        if (!typesSupported) {
          this.addError('One of the following types ' + attributeValue.join(',') + ' is not supported.');
          return callback();
        }


        var noError = attributeValue.some(function(type) {
          return types[type](propertyValue);
        });

        if (!noError) {
          this.addError();
        }

        return callback();

      /**
       * {
       *   type: 'string'
       * }
       */
      } else {

        if (!hasProperty(types, attributeValue)) {
          this.addError('Type ' + attributeValue + ' is not supported.');
        } else {
          var testSuccess = types[attributeValue](propertyValue);
          if (!testSuccess) {
            this.addError();
          }
        }

        return callback();

      }

    };

  };

  // Export
  Validation.prototype.addAttributeConstructor('type', typeConstructor);

  (function() {

    /**
     * UniqueItems
     */
    var attribute = function uniqueItems(property, propertyValue, attributeValue, propertyAttributes, callback) {

      var self =  this;

      each(propertyValue, function(index, value) {

        if (isString(value)) {
          if ((propertyValue.indexOf(value) < index)) {
            self.addError();
          }
        }

        if (isObject(value) || isArray(value)) {
          propertyValue.forEach(function(subValue, subIndex) {

            if (subIndex !== index) {
              if (isEqual(value, subValue)) {
                self.addError({
                  property: self.joinPath(property, subIndex)
                });
              }
            }

          });
        }

      });

      return callback();

    };

    // Export
    Validation.prototype.addAttribute('uniqueItems', attribute);

  }());


  /**
   * Error
   *
   * @constructor
   */
  var ValidationError = function(parent) {

    this.length = 0;
    
    this.errorMessages = parent.messages;

  };

  ValidationError.prototype.renderErrorMessage = function(error) {

    var errorMessage = this.errorMessages[error.attributeName];

    if (errorMessage && isFunction(errorMessage)) {
      return errorMessage(
        error.property,
        error.propertyValue,
        error.attributeValue
      );
    }

    if (errorMessage && isString(errorMessage)) {

      [
        'property',
        'propertyValue',
        'attributeValue'
      ].forEach(function(placeholder) {
        errorMessage = errorMessage.replace(new RegExp('{{' + placeholder + '}}', 'g'), error[placeholder]);
      });

      // Deprecated
      errorMessage = errorMessage.replace(/{{validator}}/g, error['attributeValue']);

      return errorMessage.replace(/\s+/g, ' ');

    }

    return error.message;

  };

  ValidationError.prototype.push = function(error) {

    this[this.length] = {

      property: error.property,
      propertyValue: error.propertyValue,
      attributeName: error.attributeName,
      attributeValue: error.attributeValue,
      message: this.renderErrorMessage(error),

      // Deprecated
      validator: error.attributeName,
      validatorName: error.attributeName,
      validatorValue: error.attributeValue

    };

    this.length += 1;

  };

  /**
   * GetProperties
   */
  ValidationError.prototype.getProperties = function() {
    return pluck(this, 'property');
  };

  /**
   * GetMessages
   */
  ValidationError.prototype.getMessages = function() {
    return pluck(this, 'message');
  };

  /**
   * Messages
   * --------------------
   */
  var vowels = "aeiou",
  errorMessages = {

    /**
     * Maximum
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    required: function(property, propertyValue, attributeValue) {
      return 'The ' + property + ' property is required.';
    },

    /**
     * MinLength
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    minLength: function(property, propertyValue, attributeValue) {
      return [
        'The ' + property + ' property must be at least ' + attributeValue + ' characters.',
        'The length of the property is ' + propertyValue.length + '.'
      ].join(' ');
    },

    /**
     * MaxLength
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    maxLength: function(property, propertyValue, attributeValue) {
      return [
        'The ' + property + ' property must not exceed ' + attributeValue + ' character' + (attributeValue > 1 ? 's' : '')  + '.',
        'The length of the property is ' + propertyValue.length + '.'
      ].join(' ');
    },

    /**
     * MaxLength
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    length: function(property, propertyValue, attributeValue) {
      return [
        'The ' + property + ' property must be exactly ' + attributeValue + ' character' + (attributeValue > 1 ? 's' : '')  + '.',
        'The length of the property is ' + propertyValue.length + '.'
      ].join(' ');
    },

    /**
     * Format
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    format: function(property, propertyValue, attributeValue) {
      return [
        'The ' + property + ' property must be a/an ' + attributeValue + '.',
        'The current value of the property is ' + propertyValue  + ''
      ].join(' ');
    },

    /**
     * Type
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    type: function(property, propertyValue, attributeValue) {
      return [
        'The ' + property + ' property must be ' + (vowels.indexOf(attributeValue[0]) > -1 ? 'an' : 'a') + ' ' + attributeValue + '.',
        'The type of the property is ' + detectType(propertyValue)  + ''
      ].join(' ');
    },

    /**
     * Except
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    except: function(property, propertyValue, attributeValue) {
      return;
    },

    /**
     * Minimum
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    minimum: function(property, propertyValue, attributeValue) {
      return [
        'The minimum value of the ' + property + ' must be ' + attributeValue + '.',
        'The current value of the property is ' + propertyValue  + ''
      ].join(' ');
    },

    /**
     * Maximum
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    maximum: function(property, propertyValue, attributeValue) {
      return [
        'The maximum value of the ' + property + ' must be ' + attributeValue + '.',
        'The current value of the property is ' + propertyValue  + '.'
      ].join(' ');
    },

    /**
     * Maximum
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    pattern: function(property, propertyValue, attributeValue) {
      return 'The ' + property + ' does not match the ' + attributeValue + ' pattern.';
    },

    /**
     * MaxItems
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    maxItems: function(property, propertyValue, attributeValue) {
      return [
        'The ' + property + ' property must not contain more than ' + attributeValue + ' items.',
        'Currently it contains ' + propertyValue.items  + ' items.'
      ].join(' ');
    },

    /**
     * MinItems
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    minItems: function(property, propertyValue, attributeValue) {
      return [
        'The ' + property + ' property must contain at least ' + attributeValue + ' items.',
        'Currently it contains ' + propertyValue.items  + ' items.'
      ].join(' ');
    },

    /**
     * Maximum
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    divisibleBy: function(property, propertyValue, attributeValue) {
      return 'The ' + property + ' is not divisible by ' + attributeValue + '.';
    },

    /**
     * Maximum
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    uniqueItems: function(property, propertyValue, attributeValue) {
      return 'All items in the ' + property + ' property must be unique.';
    },

    /**
     * Enum
     *
     * @param {string} property
     * @param {any} propertyValue
     * @param {string} attributeValue
     */
    'enum': function(property, propertyValue, attributeValue) {
      return 'Value of the ' + property + ' must be ' + attributeValue.join(' or ') + '.';
    }

  };

  /**
   * GetProperty
   *
   * @param {string} property
   * @param {object} source
   */
  Validation.prototype.getProperty = function(property, source) {
    if (source) {
      return (isDefined(source[property])) ? source[property] : undefined;
    } else {
      return undefined;
    }
  };

  /**
   * JoinPath
   *
   * @param {string} path
   * @param {string} property
   */
  Validation.prototype.joinPath = function(path, property) {

      path = path || [];

      //copy to avoid sharing 1 instance
      path = JSON.parse(JSON.stringify(path));

      // Converts the property to a string
      property = property + '';

      path.push(property);
      return path;

  };


  /**
   * Validation.validate
   *
   * @param {object} instance
   * @param {object} schema
   * @param {boolean} singleError
   * @param {function} callback
   */
  Validation.prototype.validate = function(instance, schema, callback) {

    // Save a reference to the this
    var self = this;

    this.instance = instance;
    this.schema = schema;

    /**
     * Basic Types
     */
    var basicTypes = [
      'string',
      'number',
      'function',
      'boolean',
      'integer',
      'int',
      'null'
    ];

    /**
     * Object Types
     */
    var objectTypes = [
      'object',
      'array'
    ];

    /**
     * CallbackProxy
     */
    var callbackProxy = function() {
      if (self.errors.length !== 0) {
        return callback(self.errors);
      } else {
        return callback();
      }
    };

    /**
     * {
     *   type: 'string',
     *   ...
     * }
     */
    if (basicTypes.indexOf(schema.type) !== -1) {
      return this.validateProperty(undefined, instance, schema, callbackProxy);
    }

    /**
     * {
     *   type: 'object',
     *   ...
     * }
     */
    if (objectTypes.indexOf(schema.type) !== -1) {

      if (isString(instance)) {
        try {
          instance = JSON.parse(instance);
        } catch(parseError) {

        }
      }

      return this.validateSchema(instance, schema, '', callbackProxy);

    }

    /**
     * {
     *   type: ???,
     *   ...
     * }
     */
    if (schema.type === 'any' || !schema.type) {

      if (isString(instance)) {
        try {
          instance = JSON.parse(instance);
          return this.validateSchema(instance, schema, '', callbackProxy);
        } catch(parseError2) {

        }
      }

      if (isObject(instance) || isArray (instance)) {
        return this.validateSchema(instance, schema, '', callbackProxy); 
      }

      return this.validateProperty(undefined, instance, schema, callbackProxy);

    }

  };

  /**
   * Validation.validateItems
   *
   * @param {object} instance
   * @param {object} schema
   * @param {string} path
   * @param {function} callback
   */
  Validation.prototype.validateItems = function(instance, schema, path, callback) {

    // Save a reference to the this
    var self = this;

    /**
     * {
     *   type: 'array'
     *   items: [
     *     {
     *       type: 'string'
     *     },
     *     {
     *       type: 'number'
     *     },
     *     ...
     *   ],
     *   ...
     * }
     */

    if (isUndefined(instance)) {
      instance = [];
    }

    if (isArray(schema.items)) {

      // Additional items are allowed
      if (isUndefined(schema.additionalItems) || schema.additionalItems === true) {
        return each(schema.items, function(itemIndex, itemSchema, callback) {
          return self.validateSchema(
            instance[itemIndex],
            itemSchema,
            self.joinPath(path, itemIndex),
            callback
          );
        }, callback);
      }

      return each(instance, function(itemIndex, itemValue, callback) {

        // The additionalItems attribute is a schema that defines
        // the schema of the additional items
        if (schema.items[itemIndex] || isObject(schema.additionalItems)) {
          return self.validateSchema(
            itemValue,
            schema.items[itemIndex],
            self.joinPath(path, itemIndex),
            callback
          );
        }

        // Additional items are disallowed
        if (schema.additionalItems === false) {
          self.errors.push({
            property: self.joinPath(path, itemIndex),
            propertyValue: itemValue,
            attributeName: 'additionalItems',
            attributeValue: false
          });
          return callback();
        }

      }, callback);

    }

    /**
     * {
     *   type: 'array'
     *   items: {
     *     type: 'string'
     *   },
     *   ...
     * }
     */
    if (isObject(schema.items) && instance && !isEmpty(instance)) {
      return each(instance, function(itemIndex, itemValue, callback) {
        return self.validateSchema(
          instance[itemIndex],
          schema.items,
          self.joinPath(path, itemIndex),
          callback
        );
      }, callback);
    } else {
      return callback();
    }

  };

  /**
   * Validation.validateProperties
   *
   * @param {object} instance
   * @param {object} schema
   * @param {string} path
   * @param {function} callback
   */
  Validation.prototype.validateProperties = function(instance, schema, path, callback) {
    
    // Save a reference to the this
    var self = this;

    // Goes
    return each(schema.properties, function(property, propertyAttributes, callback) {

      var isObject = propertyAttributes.type === 'object' && propertyAttributes.properties,
          isArray =  propertyAttributes.type === 'array';

      // Get the value of property (instance[property])
      var propertyValue = self.getProperty(property, instance);
      var propertyPath = self.joinPath(path, property);

      /**
       * {
       *   type: 'object',
       *   properties: {
       *     user: {
       *       type: 'object',
       *       properties: {
       *         ...
       *       }
       *     }
       *   }
       * }
       */
      if (isObject || isArray)  {
        return self.validateSchema(
          propertyValue,
          schema.properties[property],
          propertyPath,
          callback
        );
      } else {
        return self.validateProperty(
          propertyPath,
          propertyValue,
          propertyAttributes,
          callback
        );
      }

    }, callback);

  };

  /**
   * Validation.validateProperty
   *
   * @param {string} propertyName
   * @param {object} propertyAttributes
   * @param {string|object} propertyValue
   * @param {boolean} singleError
   * @param {function} callback
   */
  Validation.prototype.validateProperty = function(property, propertyValue, propertyAttributes, callback) {

    // Save a reference to the this
    var self = this;

    var context = {};

    [
      'validateItems',
      'validateProperties',
      'validateSchema',
      'validateProperty',
      'getProperty',
      'attributes',
      'errors',
      'joinPath'
    ].forEach(function(key) {
      context[key] = this[key];
    }, self);

    /**
     * Iterator
     *
     * @param {string} attributeName
     * @param {function} attributeFn
     * @param {function} callback
     */
    var iterator = function(attributeName, attributeFn, callback) {

      var lastLength = self.errors.length;

      // Overwrite the addError method
      context.addError = function(message) {

        if (isObject(message)) {
          property = message.property || property;

          if (!Array.isArray(property)) {
              property = [property];
          }

          return self.errors.push({
            property: property,
            propertyValue: message.propertyValue || propertyValue,
            attributeName: message.attributeName || attributeName,
            attributeValue: message.attributeValue || propertyAttributes[attributeName],
            message: message.message || undefined
          });
        }

        if (!Array.isArray(property)) {
              property = [property];
          }

        return self.errors.push({
          property: property,
          propertyValue: propertyValue,
          attributeName: attributeName,
          attributeValue: propertyAttributes[attributeName],
          message: message
        });

      };

      /**
       * OnComplete
       */
      var onComplete = function(error) {

        // Deprecated
        if (error === true || isString(error)) {
          context.addError(error);
          return callback(true);
        }
        if (self.errors.length > lastLength && self.singleError) {
          return callback(true);
        } else {
          return callback();
        }

      };

      if (isDefined(propertyAttributes[attributeName])) {
        return attributeFn.apply(context, [
          property,
          propertyValue,
          propertyAttributes[attributeName],
          propertyAttributes,
          onComplete
        ]);
      } else {
        return callback();
      }

    };

    // If it's not a required param and it's empty, skip
    if (propertyAttributes.required !== true && isUndefined(propertyValue)) {
      return callback();
    }
    
    // Validate the property  
    return each(self.attributes, iterator, callback);

  };


  /**
   * Validation.validateSchema
   *
   * @param {object} instance
   * @param {object} schema
   * @param {string} path
   * @param {function} callback
   */
  Validation.prototype.validateSchema = function(instance, schema, path, callback) {

    var self = this;

    return self.validateProperty(path, instance, schema, function(error) {

      /**
       * {
       *   type: 'object',
       *   properties: {
       *     ... 
       *   }
       * }
       */
      if (schema.properties) {
        return self.validateProperties(
          instance,
          schema,
          path,
          callback
        );

      /**
       * {
       *   type: 'array',
       *   items: {
       *     type: 'string'
       *     ... 
       *   }
       * }
       */
      } else if (schema.items) {
        return self.validateItems(
          instance,
          schema,
          path,
          callback
        );

      /**
       * {
       *   type: 'array'
       * }
       *  or 
       * {
       *   type: 'object'
       * }
       */
      } else {
        return callback();
      }

    });

  };

    
    /**
     * Export
     * --------------------
     */
    engines.json = (function() {

      return {

        /**
         * Validate
         *
         * @param {object} instance
         * @param {object} schema
         * @param {object} options
         * @param {function} callback
         */
        validate: function(instance, schema, options, callback) {
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          return (new Validation(options)).validate(instance, schema, callback);
        },

        /**
         * AddAttribute
         *
         * @param {string} attributeName
         * @param {function} attributeFn
         */
        addAttribute: function(attributeName, attributeFn) {
          return Validation.prototype.addAttribute.apply(Validation, arguments);
        },

        /**
         * AddAttributeConstructor
         *
         * @param {string} attributeName
         * @param {function} attributeConstructor
         */
        addAttributeConstructor: function(attributeName, attributeConstructor) {
          return Validation.prototype.addAttributeConstructor.apply(Validation, arguments);
        }

      };

    }());

  }());

  var amanda = function(engine) {

    if (!hasProperty(engines, engine)) {
      throw new Error('The ' + engine + ' engine is not supported. Please use a different one.');
    }

    return engines[engine];

  };

  /**
   * Amanda.validate
   *
   * This method is deprecated, please use amanda('json').validate instead.
   */
  amanda.validate = function(instance, schema, options, callback) {
    var json = engines.json;
    return json.validate.apply(json, arguments);
  };

  /**
   * Amanda.addValidator
   *
   * This method is deprecated, please use amanda('json').addValidator instead.
   */
  amanda.addValidator = function(attributeName, attributeFn) {
    var json = engines.json;
    return json.addAttribute.apply(json, arguments);
  };

  /**
   * Amanda.addAttribute
   *
   * This method is deprecated, please use amanda('json').addAttribute instead.
   */
  amanda.addAttribute = function(attributeName, attributeFn) {
    var json = engines.json;
    return json.addAttribute.apply(json, arguments);
  };

  /**
   * Amanda.addAttributeConstructor
   *
   * This method is deprecated, please use amanda('json').addAttributeConstructor instead.
   */
  amanda.addAttributeConstructor = function(attributeName, attributeConstructor) {
    var json = engines.json;
    return json.addAttributeConstructor.apply(json, arguments);
  };

    /**
     * Export
     * --------------------
     */
    if ( module.exports) {
      module.exports = amanda;
    } else {
      this.amanda = amanda;
    }

  }());
  });

  var tv4 = createCommonjsModule(function (module) {
  /*
  Author: Geraint Luff and others
  Year: 2013

  This code is released into the "public domain" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.

  If you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.
  */
  (function (global, factory) {
    if ( module.exports){
      // CommonJS. Define export.
      module.exports = factory();
    } else {
      // Browser globals
      global.tv4 = factory();
    }
  }(commonjsGlobal, function () {

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys
  if (!Object.keys) {
  	Object.keys = (function () {
  		var hasOwnProperty = Object.prototype.hasOwnProperty,
  			hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
  			dontEnums = [
  				'toString',
  				'toLocaleString',
  				'valueOf',
  				'hasOwnProperty',
  				'isPrototypeOf',
  				'propertyIsEnumerable',
  				'constructor'
  			],
  			dontEnumsLength = dontEnums.length;

  		return function (obj) {
  			if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {
  				throw new TypeError('Object.keys called on non-object');
  			}

  			var result = [];

  			for (var prop in obj) {
  				if (hasOwnProperty.call(obj, prop)) {
  					result.push(prop);
  				}
  			}

  			if (hasDontEnumBug) {
  				for (var i=0; i < dontEnumsLength; i++) {
  					if (hasOwnProperty.call(obj, dontEnums[i])) {
  						result.push(dontEnums[i]);
  					}
  				}
  			}
  			return result;
  		};
  	})();
  }
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
  if (!Object.create) {
  	Object.create = (function(){
  		function F(){}

  		return function(o){
  			if (arguments.length !== 1) {
  				throw new Error('Object.create implementation only accepts one parameter.');
  			}
  			F.prototype = o;
  			return new F();
  		};
  	})();
  }
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray
  if(!Array.isArray) {
  	Array.isArray = function (vArg) {
  		return Object.prototype.toString.call(vArg) === "[object Array]";
  	};
  }
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf
  if (!Array.prototype.indexOf) {
  	Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
  		if (this === null) {
  			throw new TypeError();
  		}
  		var t = Object(this);
  		var len = t.length >>> 0;

  		if (len === 0) {
  			return -1;
  		}
  		var n = 0;
  		if (arguments.length > 1) {
  			n = Number(arguments[1]);
  			if (n !== n) { // shortcut for verifying if it's NaN
  				n = 0;
  			} else if (n !== 0 && n !== Infinity && n !== -Infinity) {
  				n = (n > 0 || -1) * Math.floor(Math.abs(n));
  			}
  		}
  		if (n >= len) {
  			return -1;
  		}
  		var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
  		for (; k < len; k++) {
  			if (k in t && t[k] === searchElement) {
  				return k;
  			}
  		}
  		return -1;
  	};
  }

  // Grungey Object.isFrozen hack
  if (!Object.isFrozen) {
  	Object.isFrozen = function (obj) {
  		var key = "tv4_test_frozen_key";
  		while (obj.hasOwnProperty(key)) {
  			key += Math.random();
  		}
  		try {
  			obj[key] = true;
  			delete obj[key];
  			return false;
  		} catch (e) {
  			return true;
  		}
  	};
  }
  // Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed

  var uriTemplateGlobalModifiers = {
  	"+": true,
  	"#": true,
  	".": true,
  	"/": true,
  	";": true,
  	"?": true,
  	"&": true
  };
  var uriTemplateSuffices = {
  	"*": true
  };

  function notReallyPercentEncode(string) {
  	return encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {
  		return "%" + doubleEncoded.substring(3);
  	});
  }

  function uriTemplateSubstitution(spec) {
  	var modifier = "";
  	if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
  		modifier = spec.charAt(0);
  		spec = spec.substring(1);
  	}
  	var separator = "";
  	var prefix = "";
  	var shouldEscape = true;
  	var showVariables = false;
  	var trimEmptyString = false;
  	if (modifier === '+') {
  		shouldEscape = false;
  	} else if (modifier === ".") {
  		prefix = ".";
  		separator = ".";
  	} else if (modifier === "/") {
  		prefix = "/";
  		separator = "/";
  	} else if (modifier === '#') {
  		prefix = "#";
  		shouldEscape = false;
  	} else if (modifier === ';') {
  		prefix = ";";
  		separator = ";";
  		showVariables = true;
  		trimEmptyString = true;
  	} else if (modifier === '?') {
  		prefix = "?";
  		separator = "&";
  		showVariables = true;
  	} else if (modifier === '&') {
  		prefix = "&";
  		separator = "&";
  		showVariables = true;
  	}

  	var varNames = [];
  	var varList = spec.split(",");
  	var varSpecs = [];
  	for (var i = 0; i < varList.length; i++) {
  		var varName = varList[i];
  		var truncate = null;
  		if (varName.indexOf(":") !== -1) {
  			var parts = varName.split(":");
  			varName = parts[0];
  			truncate = parseInt(parts[1], 10);
  		}
  		var suffices = {};
  		while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
  			suffices[varName.charAt(varName.length - 1)] = true;
  			varName = varName.substring(0, varName.length - 1);
  		}
  		var varSpec = {
  			truncate: truncate,
  			name: varName,
  			suffices: suffices
  		};
  		varSpecs.push(varSpec);
  		varNames.push(varName);
  	}
  	var subFunction = function (valueFunction) {
  		var result = "";
  		var startIndex = 0;
  		for (var i = 0; i < varSpecs.length; i++) {
  			var varSpec = varSpecs[i];
  			var value = valueFunction(varSpec.name);
  			if (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {
  				startIndex++;
  				continue;
  			}
  			if (i === startIndex) {
  				result += prefix;
  			} else {
  				result += (separator || ",");
  			}
  			if (Array.isArray(value)) {
  				if (showVariables) {
  					result += varSpec.name + "=";
  				}
  				for (var j = 0; j < value.length; j++) {
  					if (j > 0) {
  						result += varSpec.suffices['*'] ? (separator || ",") : ",";
  						if (varSpec.suffices['*'] && showVariables) {
  							result += varSpec.name + "=";
  						}
  					}
  					result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
  				}
  			} else if (typeof value === "object") {
  				if (showVariables && !varSpec.suffices['*']) {
  					result += varSpec.name + "=";
  				}
  				var first = true;
  				for (var key in value) {
  					if (!first) {
  						result += varSpec.suffices['*'] ? (separator || ",") : ",";
  					}
  					first = false;
  					result += shouldEscape ? encodeURIComponent(key).replace(/!/g, "%21") : notReallyPercentEncode(key);
  					result += varSpec.suffices['*'] ? '=' : ",";
  					result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, "%21") : notReallyPercentEncode(value[key]);
  				}
  			} else {
  				if (showVariables) {
  					result += varSpec.name;
  					if (!trimEmptyString || value !== "") {
  						result += "=";
  					}
  				}
  				if (varSpec.truncate != null) {
  					value = value.substring(0, varSpec.truncate);
  				}
  				result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21"): notReallyPercentEncode(value);
  			}
  		}
  		return result;
  	};
  	subFunction.varNames = varNames;
  	return {
  		prefix: prefix,
  		substitution: subFunction
  	};
  }

  function UriTemplate(template) {
  	if (!(this instanceof UriTemplate)) {
  		return new UriTemplate(template);
  	}
  	var parts = template.split("{");
  	var textParts = [parts.shift()];
  	var prefixes = [];
  	var substitutions = [];
  	var varNames = [];
  	while (parts.length > 0) {
  		var part = parts.shift();
  		var spec = part.split("}")[0];
  		var remainder = part.substring(spec.length + 1);
  		var funcs = uriTemplateSubstitution(spec);
  		substitutions.push(funcs.substitution);
  		prefixes.push(funcs.prefix);
  		textParts.push(remainder);
  		varNames = varNames.concat(funcs.substitution.varNames);
  	}
  	this.fill = function (valueFunction) {
  		var result = textParts[0];
  		for (var i = 0; i < substitutions.length; i++) {
  			var substitution = substitutions[i];
  			result += substitution(valueFunction);
  			result += textParts[i + 1];
  		}
  		return result;
  	};
  	this.varNames = varNames;
  	this.template = template;
  }
  UriTemplate.prototype = {
  	toString: function () {
  		return this.template;
  	},
  	fillFromObject: function (obj) {
  		return this.fill(function (varName) {
  			return obj[varName];
  		});
  	}
  };
  var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {
  	this.missing = [];
  	this.missingMap = {};
  	this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
  	this.schemas = parent ? Object.create(parent.schemas) : {};
  	this.collectMultiple = collectMultiple;
  	this.errors = [];
  	this.handleError = collectMultiple ? this.collectError : this.returnError;
  	if (checkRecursive) {
  		this.checkRecursive = true;
  		this.scanned = [];
  		this.scannedFrozen = [];
  		this.scannedFrozenSchemas = [];
  		this.scannedFrozenValidationErrors = [];
  		this.validatedSchemasKey = 'tv4_validation_id';
  		this.validationErrorsKey = 'tv4_validation_errors_id';
  	}
  	if (trackUnknownProperties) {
  		this.trackUnknownProperties = true;
  		this.knownPropertyPaths = {};
  		this.unknownPropertyPaths = {};
  	}
  	this.errorReporter = errorReporter || defaultErrorReporter('en');
  	if (typeof this.errorReporter === 'string') {
  		throw new Error('debug');
  	}
  	this.definedKeywords = {};
  	if (parent) {
  		for (var key in parent.definedKeywords) {
  			this.definedKeywords[key] = parent.definedKeywords[key].slice(0);
  		}
  	}
  };
  ValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {
  	this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];
  	this.definedKeywords[keyword].push(keywordFunction);
  };
  ValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors, data, schema) {
  	var error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);
  	error.message = this.errorReporter(error, data, schema);
  	return error;
  };
  ValidatorContext.prototype.returnError = function (error) {
  	return error;
  };
  ValidatorContext.prototype.collectError = function (error) {
  	if (error) {
  		this.errors.push(error);
  	}
  	return null;
  };
  ValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {
  	for (var i = startIndex; i < this.errors.length; i++) {
  		this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
  	}
  	return this;
  };
  ValidatorContext.prototype.banUnknownProperties = function (data, schema) {
  	for (var unknownPath in this.unknownPropertyPaths) {
  		var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, "", null, data, schema);
  		var result = this.handleError(error);
  		if (result) {
  			return result;
  		}
  	}
  	return null;
  };

  ValidatorContext.prototype.addFormat = function (format, validator) {
  	if (typeof format === 'object') {
  		for (var key in format) {
  			this.addFormat(key, format[key]);
  		}
  		return this;
  	}
  	this.formatValidators[format] = validator;
  };
  ValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {
  	if (schema['$ref'] !== undefined) {
  		urlHistory = urlHistory || {};
  		if (urlHistory[schema['$ref']]) {
  			return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '', null, undefined, schema);
  		}
  		urlHistory[schema['$ref']] = true;
  		schema = this.getSchema(schema['$ref'], urlHistory);
  	}
  	return schema;
  };
  ValidatorContext.prototype.getSchema = function (url, urlHistory) {
  	var schema;
  	if (this.schemas[url] !== undefined) {
  		schema = this.schemas[url];
  		return this.resolveRefs(schema, urlHistory);
  	}
  	var baseUrl = url;
  	var fragment = "";
  	if (url.indexOf('#') !== -1) {
  		fragment = url.substring(url.indexOf("#") + 1);
  		baseUrl = url.substring(0, url.indexOf("#"));
  	}
  	if (typeof this.schemas[baseUrl] === 'object') {
  		schema = this.schemas[baseUrl];
  		var pointerPath = decodeURIComponent(fragment);
  		if (pointerPath === "") {
  			return this.resolveRefs(schema, urlHistory);
  		} else if (pointerPath.charAt(0) !== "/") {
  			return undefined;
  		}
  		var parts = pointerPath.split("/").slice(1);
  		for (var i = 0; i < parts.length; i++) {
  			var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
  			if (schema[component] === undefined) {
  				schema = undefined;
  				break;
  			}
  			schema = schema[component];
  		}
  		if (schema !== undefined) {
  			return this.resolveRefs(schema, urlHistory);
  		}
  	}
  	if (this.missing[baseUrl] === undefined) {
  		this.missing.push(baseUrl);
  		this.missing[baseUrl] = baseUrl;
  		this.missingMap[baseUrl] = baseUrl;
  	}
  };
  ValidatorContext.prototype.searchSchemas = function (schema, url) {
  	if (Array.isArray(schema)) {
  		for (var i = 0; i < schema.length; i++) {
  			this.searchSchemas(schema[i], url);
  		}
  	} else if (schema && typeof schema === "object") {
  		if (typeof schema.id === "string") {
  			if (isTrustedUrl(url, schema.id)) {
  				if (this.schemas[schema.id] === undefined) {
  					this.schemas[schema.id] = schema;
  				}
  			}
  		}
  		for (var key in schema) {
  			if (key !== "enum") {
  				if (typeof schema[key] === "object") {
  					this.searchSchemas(schema[key], url);
  				} else if (key === "$ref") {
  					var uri = getDocumentUri(schema[key]);
  					if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {
  						this.missingMap[uri] = uri;
  					}
  				}
  			}
  		}
  	}
  };
  ValidatorContext.prototype.addSchema = function (url, schema) {
  	//overload
  	if (typeof url !== 'string' || typeof schema === 'undefined') {
  		if (typeof url === 'object' && typeof url.id === 'string') {
  			schema = url;
  			url = schema.id;
  		}
  		else {
  			return;
  		}
  	}
  	if (url === getDocumentUri(url) + "#") {
  		// Remove empty fragment
  		url = getDocumentUri(url);
  	}
  	this.schemas[url] = schema;
  	delete this.missingMap[url];
  	normSchema(schema, url);
  	this.searchSchemas(schema, url);
  };

  ValidatorContext.prototype.getSchemaMap = function () {
  	var map = {};
  	for (var key in this.schemas) {
  		map[key] = this.schemas[key];
  	}
  	return map;
  };

  ValidatorContext.prototype.getSchemaUris = function (filterRegExp) {
  	var list = [];
  	for (var key in this.schemas) {
  		if (!filterRegExp || filterRegExp.test(key)) {
  			list.push(key);
  		}
  	}
  	return list;
  };

  ValidatorContext.prototype.getMissingUris = function (filterRegExp) {
  	var list = [];
  	for (var key in this.missingMap) {
  		if (!filterRegExp || filterRegExp.test(key)) {
  			list.push(key);
  		}
  	}
  	return list;
  };

  ValidatorContext.prototype.dropSchemas = function () {
  	this.schemas = {};
  	this.reset();
  };
  ValidatorContext.prototype.reset = function () {
  	this.missing = [];
  	this.missingMap = {};
  	this.errors = [];
  };

  ValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
  	var topLevel;
  	schema = this.resolveRefs(schema);
  	if (!schema) {
  		return null;
  	} else if (schema instanceof ValidationError) {
  		this.errors.push(schema);
  		return schema;
  	}

  	var startErrorCount = this.errors.length;
  	var frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;
  	if (this.checkRecursive && data && typeof data === 'object') {
  		topLevel = !this.scanned.length;
  		if (data[this.validatedSchemasKey]) {
  			var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
  			if (schemaIndex !== -1) {
  				this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
  				return null;
  			}
  		}
  		if (Object.isFrozen(data)) {
  			frozenIndex = this.scannedFrozen.indexOf(data);
  			if (frozenIndex !== -1) {
  				var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
  				if (frozenSchemaIndex !== -1) {
  					this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
  					return null;
  				}
  			}
  		}
  		this.scanned.push(data);
  		if (Object.isFrozen(data)) {
  			if (frozenIndex === -1) {
  				frozenIndex = this.scannedFrozen.length;
  				this.scannedFrozen.push(data);
  				this.scannedFrozenSchemas.push([]);
  			}
  			scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
  			this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
  			this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
  		} else {
  			if (!data[this.validatedSchemasKey]) {
  				try {
  					Object.defineProperty(data, this.validatedSchemasKey, {
  						value: [],
  						configurable: true
  					});
  					Object.defineProperty(data, this.validationErrorsKey, {
  						value: [],
  						configurable: true
  					});
  				} catch (e) {
  					//IE 7/8 workaround
  					data[this.validatedSchemasKey] = [];
  					data[this.validationErrorsKey] = [];
  				}
  			}
  			scannedSchemasIndex = data[this.validatedSchemasKey].length;
  			data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
  			data[this.validationErrorsKey][scannedSchemasIndex] = [];
  		}
  	}

  	var errorCount = this.errors.length;
  	var error = this.validateBasic(data, schema, dataPointerPath)
  		|| this.validateNumeric(data, schema, dataPointerPath)
  		|| this.validateString(data, schema, dataPointerPath)
  		|| this.validateArray(data, schema, dataPointerPath)
  		|| this.validateObject(data, schema, dataPointerPath)
  		|| this.validateCombinations(data, schema, dataPointerPath)
  		|| this.validateHypermedia(data, schema, dataPointerPath)
  		|| this.validateFormat(data, schema, dataPointerPath)
  		|| this.validateDefinedKeywords(data, schema, dataPointerPath)
  		|| null;

  	if (topLevel) {
  		while (this.scanned.length) {
  			var item = this.scanned.pop();
  			delete item[this.validatedSchemasKey];
  		}
  		this.scannedFrozen = [];
  		this.scannedFrozenSchemas = [];
  	}

  	if (error || errorCount !== this.errors.length) {
  		while ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {
  			var dataPart = (dataPathParts && dataPathParts.length) ? "" + dataPathParts.pop() : null;
  			var schemaPart = (schemaPathParts && schemaPathParts.length) ? "" + schemaPathParts.pop() : null;
  			if (error) {
  				error = error.prefixWith(dataPart, schemaPart);
  			}
  			this.prefixErrors(errorCount, dataPart, schemaPart);
  		}
  	}

  	if (scannedFrozenSchemaIndex !== null) {
  		this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
  	} else if (scannedSchemasIndex !== null) {
  		data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
  	}

  	return this.handleError(error);
  };
  ValidatorContext.prototype.validateFormat = function (data, schema) {
  	if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {
  		return null;
  	}
  	var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
  	if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {
  		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}, '', '/format', null, data, schema);
  	} else if (errorMessage && typeof errorMessage === 'object') {
  		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || "?"}, errorMessage.dataPath || '', errorMessage.schemaPath || "/format", null, data, schema);
  	}
  	return null;
  };
  ValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {
  	for (var key in this.definedKeywords) {
  		if (typeof schema[key] === 'undefined') {
  			continue;
  		}
  		var validationFunctions = this.definedKeywords[key];
  		for (var i = 0; i < validationFunctions.length; i++) {
  			var func = validationFunctions[i];
  			var result = func(data, schema[key], schema, dataPointerPath);
  			if (typeof result === 'string' || typeof result === 'number') {
  				return this.createError(ErrorCodes.KEYWORD_CUSTOM, {key: key, message: result}, '', '', null, data, schema).prefixWith(null, key);
  			} else if (result && typeof result === 'object') {
  				var code = result.code;
  				if (typeof code === 'string') {
  					if (!ErrorCodes[code]) {
  						throw new Error('Undefined error code (use defineError): ' + code);
  					}
  					code = ErrorCodes[code];
  				} else if (typeof code !== 'number') {
  					code = ErrorCodes.KEYWORD_CUSTOM;
  				}
  				var messageParams = (typeof result.message === 'object') ? result.message : {key: key, message: result.message || "?"};
  				var schemaPath = result.schemaPath || ("/" + key.replace(/~/g, '~0').replace(/\//g, '~1'));
  				return this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);
  			}
  		}
  	}
  	return null;
  };

  function recursiveCompare(A, B) {
  	if (A === B) {
  		return true;
  	}
  	if (A && B && typeof A === "object" && typeof B === "object") {
  		if (Array.isArray(A) !== Array.isArray(B)) {
  			return false;
  		} else if (Array.isArray(A)) {
  			if (A.length !== B.length) {
  				return false;
  			}
  			for (var i = 0; i < A.length; i++) {
  				if (!recursiveCompare(A[i], B[i])) {
  					return false;
  				}
  			}
  		} else {
  			var key;
  			for (key in A) {
  				if (B[key] === undefined && A[key] !== undefined) {
  					return false;
  				}
  			}
  			for (key in B) {
  				if (A[key] === undefined && B[key] !== undefined) {
  					return false;
  				}
  			}
  			for (key in A) {
  				if (!recursiveCompare(A[key], B[key])) {
  					return false;
  				}
  			}
  		}
  		return true;
  	}
  	return false;
  }

  ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
  	var error;
  	if (error = this.validateType(data, schema, dataPointerPath)) {
  		return error.prefixWith(null, "type");
  	}
  	if (error = this.validateEnum(data, schema, dataPointerPath)) {
  		return error.prefixWith(null, "type");
  	}
  	return null;
  };

  ValidatorContext.prototype.validateType = function validateType(data, schema) {
  	if (schema.type === undefined) {
  		return null;
  	}
  	var dataType = typeof data;
  	if (data === null) {
  		dataType = "null";
  	} else if (Array.isArray(data)) {
  		dataType = "array";
  	}
  	var allowedTypes = schema.type;
  	if (!Array.isArray(allowedTypes)) {
  		allowedTypes = [allowedTypes];
  	}

  	for (var i = 0; i < allowedTypes.length; i++) {
  		var type = allowedTypes[i];
  		if (type === dataType || (type === "integer" && dataType === "number" && (data % 1 === 0))) {
  			return null;
  		}
  	}
  	return this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join("/")}, '', '', null, data, schema);
  };

  ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
  	if (schema["enum"] === undefined) {
  		return null;
  	}
  	for (var i = 0; i < schema["enum"].length; i++) {
  		var enumVal = schema["enum"][i];
  		if (recursiveCompare(data, enumVal)) {
  			return null;
  		}
  	}
  	return this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data}, '', '', null, data, schema);
  };

  ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
  	return this.validateMultipleOf(data, schema, dataPointerPath)
  		|| this.validateMinMax(data, schema, dataPointerPath)
  		|| this.validateNaN(data, schema, dataPointerPath)
  		|| null;
  };

  var CLOSE_ENOUGH_LOW = Math.pow(2, -51);
  var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;
  ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
  	var multipleOf = schema.multipleOf || schema.divisibleBy;
  	if (multipleOf === undefined) {
  		return null;
  	}
  	if (typeof data === "number") {
  		var remainder = (data/multipleOf)%1;
  		if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {
  			return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf}, '', '', null, data, schema);
  		}
  	}
  	return null;
  };

  ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
  	if (typeof data !== "number") {
  		return null;
  	}
  	if (schema.minimum !== undefined) {
  		if (data < schema.minimum) {
  			return this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}, '', '/minimum', null, data, schema);
  		}
  		if (schema.exclusiveMinimum && data === schema.minimum) {
  			return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}, '', '/exclusiveMinimum', null, data, schema);
  		}
  	}
  	if (schema.maximum !== undefined) {
  		if (data > schema.maximum) {
  			return this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}, '', '/maximum', null, data, schema);
  		}
  		if (schema.exclusiveMaximum && data === schema.maximum) {
  			return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}, '', '/exclusiveMaximum', null, data, schema);
  		}
  	}
  	return null;
  };

  ValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {
  	if (typeof data !== "number") {
  		return null;
  	}
  	if (isNaN(data) === true || data === Infinity || data === -Infinity) {
  		return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}, '', '/type', null, data, schema);
  	}
  	return null;
  };

  ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
  	return this.validateStringLength(data, schema, dataPointerPath)
  		|| this.validateStringPattern(data, schema, dataPointerPath)
  		|| null;
  };

  ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
  	if (typeof data !== "string") {
  		return null;
  	}
  	if (schema.minLength !== undefined) {
  		if (data.length < schema.minLength) {
  			return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}, '', '/minLength', null, data, schema);
  		}
  	}
  	if (schema.maxLength !== undefined) {
  		if (data.length > schema.maxLength) {
  			return this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}, '', '/maxLength', null, data, schema);
  		}
  	}
  	return null;
  };

  ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
  	if (typeof data !== "string" || (typeof schema.pattern !== "string" && !(schema.pattern instanceof RegExp))) {
  		return null;
  	}
  	var regexp;
  	if (schema.pattern instanceof RegExp) {
  	  regexp = schema.pattern;
  	}
  	else {
  	  var body, flags = '';
  	  // Check for regular expression literals
  	  // @see http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5
  	  var literal = schema.pattern.match(/^\/(.+)\/([img]*)$/);
  	  if (literal) {
  	    body = literal[1];
  	    flags = literal[2];
  	  }
  	  else {
  	    body = schema.pattern;
  	  }
  	  regexp = new RegExp(body, flags);
  	}
  	if (!regexp.test(data)) {
  		return this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}, '', '/pattern', null, data, schema);
  	}
  	return null;
  };

  ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
  	if (!Array.isArray(data)) {
  		return null;
  	}
  	return this.validateArrayLength(data, schema, dataPointerPath)
  		|| this.validateArrayUniqueItems(data, schema, dataPointerPath)
  		|| this.validateArrayItems(data, schema, dataPointerPath)
  		|| null;
  };

  ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
  	var error;
  	if (schema.minItems !== undefined) {
  		if (data.length < schema.minItems) {
  			error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems}, '', '/minItems', null, data, schema);
  			if (this.handleError(error)) {
  				return error;
  			}
  		}
  	}
  	if (schema.maxItems !== undefined) {
  		if (data.length > schema.maxItems) {
  			error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems}, '', '/maxItems', null, data, schema);
  			if (this.handleError(error)) {
  				return error;
  			}
  		}
  	}
  	return null;
  };

  ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
  	if (schema.uniqueItems) {
  		for (var i = 0; i < data.length; i++) {
  			for (var j = i + 1; j < data.length; j++) {
  				if (recursiveCompare(data[i], data[j])) {
  					var error = this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j}, '', '/uniqueItems', null, data, schema);
  					if (this.handleError(error)) {
  						return error;
  					}
  				}
  			}
  		}
  	}
  	return null;
  };

  ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
  	if (schema.items === undefined) {
  		return null;
  	}
  	var error, i;
  	if (Array.isArray(schema.items)) {
  		for (i = 0; i < data.length; i++) {
  			if (i < schema.items.length) {
  				if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
  					return error;
  				}
  			} else if (schema.additionalItems !== undefined) {
  				if (typeof schema.additionalItems === "boolean") {
  					if (!schema.additionalItems) {
  						error = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, '/' + i, '/additionalItems', null, data, schema));
  						if (this.handleError(error)) {
  							return error;
  						}
  					}
  				} else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
  					return error;
  				}
  			}
  		}
  	} else {
  		for (i = 0; i < data.length; i++) {
  			if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
  				return error;
  			}
  		}
  	}
  	return null;
  };

  ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
  	if (typeof data !== "object" || data === null || Array.isArray(data)) {
  		return null;
  	}
  	return this.validateObjectMinMaxProperties(data, schema, dataPointerPath)
  		|| this.validateObjectRequiredProperties(data, schema, dataPointerPath)
  		|| this.validateObjectProperties(data, schema, dataPointerPath)
  		|| this.validateObjectDependencies(data, schema, dataPointerPath)
  		|| null;
  };

  ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
  	var keys = Object.keys(data);
  	var error;
  	if (schema.minProperties !== undefined) {
  		if (keys.length < schema.minProperties) {
  			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}, '', '/minProperties', null, data, schema);
  			if (this.handleError(error)) {
  				return error;
  			}
  		}
  	}
  	if (schema.maxProperties !== undefined) {
  		if (keys.length > schema.maxProperties) {
  			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}, '', '/maxProperties', null, data, schema);
  			if (this.handleError(error)) {
  				return error;
  			}
  		}
  	}
  	return null;
  };

  ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
  	if (schema.required !== undefined) {
  		for (var i = 0; i < schema.required.length; i++) {
  			var key = schema.required[i];
  			if (data[key] === undefined) {
  				var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}, '', '/required/' + i, null, data, schema);
  				if (this.handleError(error)) {
  					return error;
  				}
  			}
  		}
  	}
  	return null;
  };

  ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
  	var error;
  	for (var key in data) {
  		var keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, '~0').replace(/\//g, '~1');
  		var foundMatch = false;
  		if (schema.properties !== undefined && schema.properties[key] !== undefined) {
  			foundMatch = true;
  			if (error = this.validateAll(data[key], schema.properties[key], [key], ["properties", key], keyPointerPath)) {
  				return error;
  			}
  		}
  		if (schema.patternProperties !== undefined) {
  			for (var patternKey in schema.patternProperties) {
  				var regexp = new RegExp(patternKey);
  				if (regexp.test(key)) {
  					foundMatch = true;
  					if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], ["patternProperties", patternKey], keyPointerPath)) {
  						return error;
  					}
  				}
  			}
  		}
  		if (!foundMatch) {
  			if (schema.additionalProperties !== undefined) {
  				if (this.trackUnknownProperties) {
  					this.knownPropertyPaths[keyPointerPath] = true;
  					delete this.unknownPropertyPaths[keyPointerPath];
  				}
  				if (typeof schema.additionalProperties === "boolean") {
  					if (!schema.additionalProperties) {
  						error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {key: key}, '', '/additionalProperties', null, data, schema).prefixWith(key, null);
  						if (this.handleError(error)) {
  							return error;
  						}
  					}
  				} else {
  					if (error = this.validateAll(data[key], schema.additionalProperties, [key], ["additionalProperties"], keyPointerPath)) {
  						return error;
  					}
  				}
  			} else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {
  				this.unknownPropertyPaths[keyPointerPath] = true;
  			}
  		} else if (this.trackUnknownProperties) {
  			this.knownPropertyPaths[keyPointerPath] = true;
  			delete this.unknownPropertyPaths[keyPointerPath];
  		}
  	}
  	return null;
  };

  ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
  	var error;
  	if (schema.dependencies !== undefined) {
  		for (var depKey in schema.dependencies) {
  			if (data[depKey] !== undefined) {
  				var dep = schema.dependencies[depKey];
  				if (typeof dep === "string") {
  					if (data[dep] === undefined) {
  						error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}, '', '', null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
  						if (this.handleError(error)) {
  							return error;
  						}
  					}
  				} else if (Array.isArray(dep)) {
  					for (var i = 0; i < dep.length; i++) {
  						var requiredKey = dep[i];
  						if (data[requiredKey] === undefined) {
  							error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}, '', '/' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
  							if (this.handleError(error)) {
  								return error;
  							}
  						}
  					}
  				} else {
  					if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
  						return error;
  					}
  				}
  			}
  		}
  	}
  	return null;
  };

  ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
  	return this.validateAllOf(data, schema, dataPointerPath)
  		|| this.validateAnyOf(data, schema, dataPointerPath)
  		|| this.validateOneOf(data, schema, dataPointerPath)
  		|| this.validateNot(data, schema, dataPointerPath)
  		|| null;
  };

  ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
  	if (schema.allOf === undefined) {
  		return null;
  	}
  	var error;
  	for (var i = 0; i < schema.allOf.length; i++) {
  		var subSchema = schema.allOf[i];
  		if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
  			return error;
  		}
  	}
  	return null;
  };

  ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
  	if (schema.anyOf === undefined) {
  		return null;
  	}
  	var errors = [];
  	var startErrorCount = this.errors.length;
  	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
  	if (this.trackUnknownProperties) {
  		oldUnknownPropertyPaths = this.unknownPropertyPaths;
  		oldKnownPropertyPaths = this.knownPropertyPaths;
  	}
  	var errorAtEnd = true;
  	for (var i = 0; i < schema.anyOf.length; i++) {
  		if (this.trackUnknownProperties) {
  			this.unknownPropertyPaths = {};
  			this.knownPropertyPaths = {};
  		}
  		var subSchema = schema.anyOf[i];

  		var errorCount = this.errors.length;
  		var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);

  		if (error === null && errorCount === this.errors.length) {
  			this.errors = this.errors.slice(0, startErrorCount);

  			if (this.trackUnknownProperties) {
  				for (var knownKey in this.knownPropertyPaths) {
  					oldKnownPropertyPaths[knownKey] = true;
  					delete oldUnknownPropertyPaths[knownKey];
  				}
  				for (var unknownKey in this.unknownPropertyPaths) {
  					if (!oldKnownPropertyPaths[unknownKey]) {
  						oldUnknownPropertyPaths[unknownKey] = true;
  					}
  				}
  				// We need to continue looping so we catch all the property definitions, but we don't want to return an error
  				errorAtEnd = false;
  				continue;
  			}

  			return null;
  		}
  		if (error) {
  			errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
  		}
  	}
  	if (this.trackUnknownProperties) {
  		this.unknownPropertyPaths = oldUnknownPropertyPaths;
  		this.knownPropertyPaths = oldKnownPropertyPaths;
  	}
  	if (errorAtEnd) {
  		errors = errors.concat(this.errors.slice(startErrorCount));
  		this.errors = this.errors.slice(0, startErrorCount);
  		return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors, data, schema);
  	}
  };

  ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
  	if (schema.oneOf === undefined) {
  		return null;
  	}
  	var validIndex = null;
  	var errors = [];
  	var startErrorCount = this.errors.length;
  	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
  	if (this.trackUnknownProperties) {
  		oldUnknownPropertyPaths = this.unknownPropertyPaths;
  		oldKnownPropertyPaths = this.knownPropertyPaths;
  	}
  	for (var i = 0; i < schema.oneOf.length; i++) {
  		if (this.trackUnknownProperties) {
  			this.unknownPropertyPaths = {};
  			this.knownPropertyPaths = {};
  		}
  		var subSchema = schema.oneOf[i];

  		var errorCount = this.errors.length;
  		var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);

  		if (error === null && errorCount === this.errors.length) {
  			if (validIndex === null) {
  				validIndex = i;
  			} else {
  				this.errors = this.errors.slice(0, startErrorCount);
  				return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, "", "/oneOf", null, data, schema);
  			}
  			if (this.trackUnknownProperties) {
  				for (var knownKey in this.knownPropertyPaths) {
  					oldKnownPropertyPaths[knownKey] = true;
  					delete oldUnknownPropertyPaths[knownKey];
  				}
  				for (var unknownKey in this.unknownPropertyPaths) {
  					if (!oldKnownPropertyPaths[unknownKey]) {
  						oldUnknownPropertyPaths[unknownKey] = true;
  					}
  				}
  			}
  		} else if (error) {
  			errors.push(error);
  		}
  	}
  	if (this.trackUnknownProperties) {
  		this.unknownPropertyPaths = oldUnknownPropertyPaths;
  		this.knownPropertyPaths = oldKnownPropertyPaths;
  	}
  	if (validIndex === null) {
  		errors = errors.concat(this.errors.slice(startErrorCount));
  		this.errors = this.errors.slice(0, startErrorCount);
  		return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors, data, schema);
  	} else {
  		this.errors = this.errors.slice(0, startErrorCount);
  	}
  	return null;
  };

  ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
  	if (schema.not === undefined) {
  		return null;
  	}
  	var oldErrorCount = this.errors.length;
  	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
  	if (this.trackUnknownProperties) {
  		oldUnknownPropertyPaths = this.unknownPropertyPaths;
  		oldKnownPropertyPaths = this.knownPropertyPaths;
  		this.unknownPropertyPaths = {};
  		this.knownPropertyPaths = {};
  	}
  	var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
  	var notErrors = this.errors.slice(oldErrorCount);
  	this.errors = this.errors.slice(0, oldErrorCount);
  	if (this.trackUnknownProperties) {
  		this.unknownPropertyPaths = oldUnknownPropertyPaths;
  		this.knownPropertyPaths = oldKnownPropertyPaths;
  	}
  	if (error === null && notErrors.length === 0) {
  		return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not", null, data, schema);
  	}
  	return null;
  };

  ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {
  	if (!schema.links) {
  		return null;
  	}
  	var error;
  	for (var i = 0; i < schema.links.length; i++) {
  		var ldo = schema.links[i];
  		if (ldo.rel === "describedby") {
  			var template = new UriTemplate(ldo.href);
  			var allPresent = true;
  			for (var j = 0; j < template.varNames.length; j++) {
  				if (!(template.varNames[j] in data)) {
  					allPresent = false;
  					break;
  				}
  			}
  			if (allPresent) {
  				var schemaUrl = template.fillFromObject(data);
  				var subSchema = {"$ref": schemaUrl};
  				if (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {
  					return error;
  				}
  			}
  		}
  	}
  };

  // parseURI() and resolveUrl() are from https://gist.github.com/1088850
  //   -  released as public domain by author ("Yaffle") - see comments on gist

  function parseURI(url) {
  	var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
  	// authority = '//' + user + ':' + pass '@' + hostname + ':' port
  	return (m ? {
  		href     : m[0] || '',
  		protocol : m[1] || '',
  		authority: m[2] || '',
  		host     : m[3] || '',
  		hostname : m[4] || '',
  		port     : m[5] || '',
  		pathname : m[6] || '',
  		search   : m[7] || '',
  		hash     : m[8] || ''
  	} : null);
  }

  function resolveUrl(base, href) {// RFC 3986

  	function removeDotSegments(input) {
  		var output = [];
  		input.replace(/^(\.\.?(\/|$))+/, '')
  			.replace(/\/(\.(\/|$))+/g, '/')
  			.replace(/\/\.\.$/, '/../')
  			.replace(/\/?[^\/]*/g, function (p) {
  				if (p === '/..') {
  					output.pop();
  				} else {
  					output.push(p);
  				}
  		});
  		return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
  	}

  	href = parseURI(href || '');
  	base = parseURI(base || '');

  	return !href || !base ? null : (href.protocol || base.protocol) +
  		(href.protocol || href.authority ? href.authority : base.authority) +
  		removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
  		(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
  		href.hash;
  }

  function getDocumentUri(uri) {
  	return uri.split('#')[0];
  }
  function normSchema(schema, baseUri) {
  	if (schema && typeof schema === "object") {
  		if (baseUri === undefined) {
  			baseUri = schema.id;
  		} else if (typeof schema.id === "string") {
  			baseUri = resolveUrl(baseUri, schema.id);
  			schema.id = baseUri;
  		}
  		if (Array.isArray(schema)) {
  			for (var i = 0; i < schema.length; i++) {
  				normSchema(schema[i], baseUri);
  			}
  		} else {
  			if (typeof schema['$ref'] === "string") {
  				schema['$ref'] = resolveUrl(baseUri, schema['$ref']);
  			}
  			for (var key in schema) {
  				if (key !== "enum") {
  					normSchema(schema[key], baseUri);
  				}
  			}
  		}
  	}
  }

  function defaultErrorReporter(language) {
  	language = language || 'en';

  	var errorMessages = languages[language];

  	return function (error) {
  		var messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];
  		if (typeof messageTemplate !== 'string') {
  			return "Unknown error code " + error.code + ": " + JSON.stringify(error.messageParams);
  		}
  		var messageParams = error.params;
  		// Adapted from Crockford's supplant()
  		return messageTemplate.replace(/\{([^{}]*)\}/g, function (whole, varName) {
  			var subValue = messageParams[varName];
  			return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;
  		});
  	};
  }

  var ErrorCodes = {
  	INVALID_TYPE: 0,
  	ENUM_MISMATCH: 1,
  	ANY_OF_MISSING: 10,
  	ONE_OF_MISSING: 11,
  	ONE_OF_MULTIPLE: 12,
  	NOT_PASSED: 13,
  	// Numeric errors
  	NUMBER_MULTIPLE_OF: 100,
  	NUMBER_MINIMUM: 101,
  	NUMBER_MINIMUM_EXCLUSIVE: 102,
  	NUMBER_MAXIMUM: 103,
  	NUMBER_MAXIMUM_EXCLUSIVE: 104,
  	NUMBER_NOT_A_NUMBER: 105,
  	// String errors
  	STRING_LENGTH_SHORT: 200,
  	STRING_LENGTH_LONG: 201,
  	STRING_PATTERN: 202,
  	// Object errors
  	OBJECT_PROPERTIES_MINIMUM: 300,
  	OBJECT_PROPERTIES_MAXIMUM: 301,
  	OBJECT_REQUIRED: 302,
  	OBJECT_ADDITIONAL_PROPERTIES: 303,
  	OBJECT_DEPENDENCY_KEY: 304,
  	// Array errors
  	ARRAY_LENGTH_SHORT: 400,
  	ARRAY_LENGTH_LONG: 401,
  	ARRAY_UNIQUE: 402,
  	ARRAY_ADDITIONAL_ITEMS: 403,
  	// Custom/user-defined errors
  	FORMAT_CUSTOM: 500,
  	KEYWORD_CUSTOM: 501,
  	// Schema structure
  	CIRCULAR_REFERENCE: 600,
  	// Non-standard validation options
  	UNKNOWN_PROPERTY: 1000
  };
  var ErrorCodeLookup = {};
  for (var key in ErrorCodes) {
  	ErrorCodeLookup[ErrorCodes[key]] = key;
  }
  var ErrorMessagesDefault = {
  	INVALID_TYPE: "Invalid type: {type} (expected {expected})",
  	ENUM_MISMATCH: "No enum match for: {value}",
  	ANY_OF_MISSING: "Data does not match any schemas from \"anyOf\"",
  	ONE_OF_MISSING: "Data does not match any schemas from \"oneOf\"",
  	ONE_OF_MULTIPLE: "Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}",
  	NOT_PASSED: "Data matches schema from \"not\"",
  	// Numeric errors
  	NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
  	NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
  	NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
  	NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
  	NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
  	NUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",
  	// String errors
  	STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
  	STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
  	STRING_PATTERN: "String does not match pattern: {pattern}",
  	// Object errors
  	OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
  	OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
  	OBJECT_REQUIRED: "Missing required property: {key}",
  	OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
  	OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
  	// Array errors
  	ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
  	ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
  	ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
  	ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
  	// Format errors
  	FORMAT_CUSTOM: "Format validation failed ({message})",
  	KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
  	// Schema structure
  	CIRCULAR_REFERENCE: "Circular $refs: {urls}",
  	// Non-standard validation options
  	UNKNOWN_PROPERTY: "Unknown property (not in schema)"
  };

  function ValidationError(code, params, dataPath, schemaPath, subErrors) {
  	Error.call(this);
  	if (code === undefined) {
  		throw new Error ("No error code supplied: " + schemaPath);
  	}
  	this.message = '';
  	this.params = params;
  	this.code = code;
  	this.dataPath = dataPath || "";
  	this.schemaPath = schemaPath || "";
  	this.subErrors = subErrors || null;

  	var err = new Error(this.message);
  	this.stack = err.stack || err.stacktrace;
  	if (!this.stack) {
  		try {
  			throw err;
  		}
  		catch(err) {
  			this.stack = err.stack || err.stacktrace;
  		}
  	}
  }
  ValidationError.prototype = Object.create(Error.prototype);
  ValidationError.prototype.constructor = ValidationError;
  ValidationError.prototype.name = 'ValidationError';

  ValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {
  	if (dataPrefix !== null) {
  		dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
  		this.dataPath = "/" + dataPrefix + this.dataPath;
  	}
  	if (schemaPrefix !== null) {
  		schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
  		this.schemaPath = "/" + schemaPrefix + this.schemaPath;
  	}
  	if (this.subErrors !== null) {
  		for (var i = 0; i < this.subErrors.length; i++) {
  			this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
  		}
  	}
  	return this;
  };

  function isTrustedUrl(baseUrl, testUrl) {
  	if(testUrl.substring(0, baseUrl.length) === baseUrl){
  		var remainder = testUrl.substring(baseUrl.length);
  		if ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/")
  			|| remainder.charAt(0) === "#"
  			|| remainder.charAt(0) === "?") {
  			return true;
  		}
  	}
  	return false;
  }

  var languages = {};
  function createApi(language) {
  	var globalContext = new ValidatorContext();
  	var currentLanguage;
  	var customErrorReporter;
  	var api = {
  		setErrorReporter: function (reporter) {
  			if (typeof reporter === 'string') {
  				return this.language(reporter);
  			}
  			customErrorReporter = reporter;
  			return true;
  		},
  		addFormat: function () {
  			globalContext.addFormat.apply(globalContext, arguments);
  		},
  		language: function (code) {
  			if (!code) {
  				return currentLanguage;
  			}
  			if (!languages[code]) {
  				code = code.split('-')[0]; // fall back to base language
  			}
  			if (languages[code]) {
  				currentLanguage = code;
  				return code; // so you can tell if fall-back has happened
  			}
  			return false;
  		},
  		addLanguage: function (code, messageMap) {
  			var key;
  			for (key in ErrorCodes) {
  				if (messageMap[key] && !messageMap[ErrorCodes[key]]) {
  					messageMap[ErrorCodes[key]] = messageMap[key];
  				}
  			}
  			var rootCode = code.split('-')[0];
  			if (!languages[rootCode]) { // use for base language if not yet defined
  				languages[code] = messageMap;
  				languages[rootCode] = messageMap;
  			} else {
  				languages[code] = Object.create(languages[rootCode]);
  				for (key in messageMap) {
  					if (typeof languages[rootCode][key] === 'undefined') {
  						languages[rootCode][key] = messageMap[key];
  					}
  					languages[code][key] = messageMap[key];
  				}
  			}
  			return this;
  		},
  		freshApi: function (language) {
  			var result = createApi();
  			if (language) {
  				result.language(language);
  			}
  			return result;
  		},
  		validate: function (data, schema, checkRecursive, banUnknownProperties) {
  			var def = defaultErrorReporter(currentLanguage);
  			var errorReporter = customErrorReporter ? function (error, data, schema) {
  				return customErrorReporter(error, data, schema) || def(error, data, schema);
  			} : def;
  			var context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);
  			if (typeof schema === "string") {
  				schema = {"$ref": schema};
  			}
  			context.addSchema("", schema);
  			var error = context.validateAll(data, schema, null, null, "");
  			if (!error && banUnknownProperties) {
  				error = context.banUnknownProperties(data, schema);
  			}
  			this.error = error;
  			this.missing = context.missing;
  			this.valid = (error === null);
  			return this.valid;
  		},
  		validateResult: function () {
  			var result = {toString: function () {
  				return this.valid ? 'valid' : this.error.message;
  			}};
  			this.validate.apply(result, arguments);
  			return result;
  		},
  		validateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {
  			var def = defaultErrorReporter(currentLanguage);
  			var errorReporter = customErrorReporter ? function (error, data, schema) {
  				return customErrorReporter(error, data, schema) || def(error, data, schema);
  			} : def;
  			var context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);
  			if (typeof schema === "string") {
  				schema = {"$ref": schema};
  			}
  			context.addSchema("", schema);
  			context.validateAll(data, schema, null, null, "");
  			if (banUnknownProperties) {
  				context.banUnknownProperties(data, schema);
  			}
  			var result = {toString: function () {
  				return this.valid ? 'valid' : this.error.message;
  			}};
  			result.errors = context.errors;
  			result.missing = context.missing;
  			result.valid = (result.errors.length === 0);
  			return result;
  		},
  		addSchema: function () {
  			return globalContext.addSchema.apply(globalContext, arguments);
  		},
  		getSchema: function () {
  			return globalContext.getSchema.apply(globalContext, arguments);
  		},
  		getSchemaMap: function () {
  			return globalContext.getSchemaMap.apply(globalContext, arguments);
  		},
  		getSchemaUris: function () {
  			return globalContext.getSchemaUris.apply(globalContext, arguments);
  		},
  		getMissingUris: function () {
  			return globalContext.getMissingUris.apply(globalContext, arguments);
  		},
  		dropSchemas: function () {
  			globalContext.dropSchemas.apply(globalContext, arguments);
  		},
  		defineKeyword: function () {
  			globalContext.defineKeyword.apply(globalContext, arguments);
  		},
  		defineError: function (codeName, codeNumber, defaultMessage) {
  			if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {
  				throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');
  			}
  			if (typeof codeNumber !== 'number' || codeNumber%1 !== 0 || codeNumber < 10000) {
  				throw new Error('Code number must be an integer > 10000');
  			}
  			if (typeof ErrorCodes[codeName] !== 'undefined') {
  				throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);
  			}
  			if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {
  				throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);
  			}
  			ErrorCodes[codeName] = codeNumber;
  			ErrorCodeLookup[codeNumber] = codeName;
  			ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
  			for (var langCode in languages) {
  				var language = languages[langCode];
  				if (language[codeName]) {
  					language[codeNumber] = language[codeNumber] || language[codeName];
  				}
  			}
  		},
  		reset: function () {
  			globalContext.reset();
  			this.error = null;
  			this.missing = [];
  			this.valid = true;
  		},
  		missing: [],
  		error: null,
  		valid: true,
  		normSchema: normSchema,
  		resolveUrl: resolveUrl,
  		getDocumentUri: getDocumentUri,
  		errorCodes: ErrorCodes
  	};
  	api.language(language || 'en');
  	return api;
  }

  var tv4 = createApi();
  tv4.addLanguage('en-gb', ErrorMessagesDefault);

  //legacy property
  tv4.tv4 = tv4;

  return tv4; // used by _header.js to globalise.

  }));
  });

  var hasOwn = Object.prototype.hasOwnProperty;
  var toString = Object.prototype.toString;

  var foreach = function forEach (obj, fn, ctx) {
      if (toString.call(fn) !== '[object Function]') {
          throw new TypeError('iterator must be a function');
      }
      var l = obj.length;
      if (l === +l) {
          for (var i = 0; i < l; i++) {
              fn.call(ctx, obj[i], i, obj);
          }
      } else {
          for (var k in obj) {
              if (hasOwn.call(obj, k)) {
                  fn.call(ctx, obj[k], k, obj);
              }
          }
      }
  };

  var jsonPointer = api;


  /**
   * Convenience wrapper around the api.
   * Calls `.get` when called with an `object` and a `pointer`.
   * Calls `.set` when also called with `value`.
   * If only supplied `object`, returns a partially applied function, mapped to the object.
   *
   * @param {Object} obj
   * @param {String|Array} pointer
   * @param value
   * @returns {*}
   */

  function api (obj, pointer, value) {
      // .set()
      if (arguments.length === 3) {
          return api.set(obj, pointer, value);
      }
      // .get()
      if (arguments.length === 2) {
          return api.get(obj, pointer);
      }
      // Return a partially applied function on `obj`.
      var wrapped = api.bind(api, obj);

      // Support for oo style
      for (var name in api) {
          if (api.hasOwnProperty(name)) {
              wrapped[name] = api[name].bind(wrapped, obj);
          }
      }
      return wrapped;
  }


  /**
   * Lookup a json pointer in an object
   *
   * @param {Object} obj
   * @param {String|Array} pointer
   * @returns {*}
   */
  api.get = function get (obj, pointer) {
      var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);

      for (var i = 0; i < refTokens.length; ++i) {
          var tok = refTokens[i];
          if (!(typeof obj == 'object' && tok in obj)) {
              throw new Error('Invalid reference token: ' + tok);
          }
          obj = obj[tok];
      }
      return obj;
  };

  /**
   * Sets a value on an object
   *
   * @param {Object} obj
   * @param {String|Array} pointer
   * @param value
   */
  api.set = function set (obj, pointer, value) {
      var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),
        nextTok = refTokens[0];

      for (var i = 0; i < refTokens.length - 1; ++i) {
          var tok = refTokens[i];
          if (tok === '-' && Array.isArray(obj)) {
            tok = obj.length;
          }
          nextTok = refTokens[i + 1];

          if (!(tok in obj)) {
              if (nextTok.match(/^(\d+|-)$/)) {
                  obj[tok] = [];
              } else {
                  obj[tok] = {};
              }
          }
          obj = obj[tok];
      }
      if (nextTok === '-' && Array.isArray(obj)) {
        nextTok = obj.length;
      }
      obj[nextTok] = value;
      return this;
  };

  /**
   * Removes an attribute
   *
   * @param {Object} obj
   * @param {String|Array} pointer
   */
  api.remove = function (obj, pointer) {
      var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);
      var finalToken = refTokens[refTokens.length -1];
      if (finalToken === undefined) {
          throw new Error('Invalid JSON pointer for remove: "' + pointer + '"');
      }

      var parent = api.get(obj, refTokens.slice(0, -1));
      if (Array.isArray(parent)) {
        var index = +finalToken;
        if (finalToken === '' && isNaN(index)) {
          throw new Error('Invalid array index: "' + finalToken + '"');
        }

        Array.prototype.splice.call(parent, index, 1);
      } else {
        delete parent[finalToken];
      }
  };

  /**
   * Returns a (pointer -> value) dictionary for an object
   *
   * @param obj
   * @param {function} descend
   * @returns {}
   */
  api.dict = function dict (obj, descend) {
      var results = {};
      api.walk(obj, function (value, pointer) {
          results[pointer] = value;
      }, descend);
      return results;
  };

  /**
   * Iterates over an object
   * Iterator: function (value, pointer) {}
   *
   * @param obj
   * @param {function} iterator
   * @param {function} descend
   */
  api.walk = function walk (obj, iterator, descend) {
      var refTokens = [];

      descend = descend || function (value) {
          var type = Object.prototype.toString.call(value);
          return type === '[object Object]' || type === '[object Array]';
      };

      (function next (cur) {
          foreach(cur, function (value, key) {
              refTokens.push(String(key));
              if (descend(value)) {
                  next(value);
              } else {
                  iterator(value, api.compile(refTokens));
              }
              refTokens.pop();
          });
      }(obj));
  };

  /**
   * Tests if an object has a value for a json pointer
   *
   * @param obj
   * @param pointer
   * @returns {boolean}
   */
  api.has = function has (obj, pointer) {
      try {
          api.get(obj, pointer);
      } catch (e) {
          return false;
      }
      return true;
  };

  /**
   * Escapes a reference token
   *
   * @param str
   * @returns {string}
   */
  api.escape = function escape (str) {
      return str.toString().replace(/~/g, '~0').replace(/\//g, '~1');
  };

  /**
   * Unescapes a reference token
   *
   * @param str
   * @returns {string}
   */
  api.unescape = function unescape (str) {
      return str.replace(/~1/g, '/').replace(/~0/g, '~');
  };

  /**
   * Converts a json pointer into a array of reference tokens
   *
   * @param pointer
   * @returns {Array}
   */
  api.parse = function parse (pointer) {
      if (pointer === '') { return []; }
      if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }
      return pointer.substring(1).split(/\//).map(api.unescape);
  };

  /**
   * Builds a json pointer from a array of reference tokens
   *
   * @param refTokens
   * @returns {string}
   */
  api.compile = function compile (refTokens) {
      if (refTokens.length === 0) { return ''; }
      return '/' + refTokens.map(api.escape).join('/');
  };

  /**
   * Parses JSON.
   *
   * Previously we've used jsonlint and jju for parsing. While we've stepped
   * back to use plain JSON.parse(), we keep our doors open to switch the parser
   * - which is the reason why this is abstracted into parseJson()
   */
  const parseJson = (json, revivew) => {
    return JSON.parse(json, revivew);
  };

  var parseJson_1 = parseJson;

  var metaSchemaV3 = {
    $schema: 'http://json-schema.org/draft-03/schema#',
    id: 'http://json-schema.org/draft-03/schema#',
    type: 'object',

    properties: {
      type: {
        type: ['string', 'array'],
        items: {
          type: ['string', { $ref: '#' }],
        },
        uniqueItems: true,
        default: 'any',
      },

      properties: {
        type: 'object',
        additionalProperties: { $ref: '#' },
        default: {},
      },

      patternProperties: {
        type: 'object',
        additionalProperties: { $ref: '#' },
        default: {},
      },

      additionalProperties: {
        type: [{ $ref: '#' }, 'boolean'],
        default: {},
      },

      items: {
        type: [{ $ref: '#' }, 'array'],
        items: { $ref: '#' },
        default: {},
      },

      additionalItems: {
        type: [{ $ref: '#' }, 'boolean'],
        default: {},
      },

      required: {
        type: 'boolean',
        default: false,
      },

      dependencies: {
        type: 'object',
        additionalProperties: {
          type: ['string', 'array', { $ref: '#' }],
          items: {
            type: 'string',
          },
        },
        default: {},
      },

      minimum: {
        type: 'number',
      },

      maximum: {
        type: 'number',
      },

      exclusiveMinimum: {
        type: 'boolean',
        default: false,
      },

      exclusiveMaximum: {
        type: 'boolean',
        default: false,
      },

      minItems: {
        type: 'integer',
        minimum: 0,
        default: 0,
      },

      maxItems: {
        type: 'integer',
        minimum: 0,
      },

      uniqueItems: {
        type: 'boolean',
        default: false,
      },

      pattern: {
        type: 'string',
        format: 'regex',
      },

      minLength: {
        type: 'integer',
        minimum: 0,
        default: 0,
      },

      maxLength: {
        type: 'integer',
      },

      enum: {
        type: 'array',
        minItems: 1,
        uniqueItems: true,
      },

      default: {
        type: 'any',
      },

      title: {
        type: 'string',
      },

      description: {
        type: 'string',
      },

      format: {
        type: 'string',
      },

      divisibleBy: {
        type: 'number',
        minimum: 0,
        exclusiveMinimum: true,
        default: 1,
      },

      disallow: {
        type: ['string', 'array'],
        items: {
          type: ['string', { $ref: '#' }],
        },
        uniqueItems: true,
      },

      extends: {
        type: [{ $ref: '#' }, 'array'],
        items: { $ref: '#' },
        default: {},
      },

      id: {
        type: 'string',
        format: 'uri',
      },

      $ref: {
        type: 'string',
        format: 'uri',
      },

      $schema: {
        type: 'string',
        format: 'uri',
      },
    },

    dependencies: {
      exclusiveMinimum: 'minimum',
      exclusiveMaximum: 'maximum',
    },

    default: {},
  };

  var metaSchemaV4 = {
    id: 'http://json-schema.org/draft-04/schema#',
    $schema: 'http://json-schema.org/draft-04/schema#',
    description: 'Core schema meta-schema',
    definitions: {
      schemaArray: {
        type: 'array',
        minItems: 1,
        items: { $ref: '#' },
      },
      positiveInteger: {
        type: 'integer',
        minimum: 0,
      },
      positiveIntegerDefault0: {
        allOf: [{ $ref: '#/definitions/positiveInteger' }, { default: 0 }],
      },
      simpleTypes: {
        enum: [
          'array',
          'boolean',
          'integer',
          'null',
          'number',
          'object',
          'string',
        ],
      },
      stringArray: {
        type: 'array',
        items: { type: 'string' },
        minItems: 1,
        uniqueItems: true,
      },
    },
    type: 'object',
    properties: {
      id: {
        type: 'string',
        format: 'uri',
      },
      $schema: {
        type: 'string',
        format: 'uri',
      },
      title: {
        type: 'string',
      },
      description: {
        type: 'string',
      },
      default: {},
      multipleOf: {
        type: 'number',
        minimum: 0,
        exclusiveMinimum: true,
      },
      maximum: {
        type: 'number',
      },
      exclusiveMaximum: {
        type: 'boolean',
        default: false,
      },
      minimum: {
        type: 'number',
      },
      exclusiveMinimum: {
        type: 'boolean',
        default: false,
      },
      maxLength: { $ref: '#/definitions/positiveInteger' },
      minLength: { $ref: '#/definitions/positiveIntegerDefault0' },
      pattern: {
        type: 'string',
        format: 'regex',
      },
      additionalItems: {
        anyOf: [{ type: 'boolean' }, { $ref: '#' }],
        default: {},
      },
      items: {
        anyOf: [{ $ref: '#' }, { $ref: '#/definitions/schemaArray' }],
        default: {},
      },
      maxItems: { $ref: '#/definitions/positiveInteger' },
      minItems: { $ref: '#/definitions/positiveIntegerDefault0' },
      uniqueItems: {
        type: 'boolean',
        default: false,
      },
      maxProperties: { $ref: '#/definitions/positiveInteger' },
      minProperties: { $ref: '#/definitions/positiveIntegerDefault0' },
      required: { $ref: '#/definitions/stringArray' },
      additionalProperties: {
        anyOf: [{ type: 'boolean' }, { $ref: '#' }],
        default: {},
      },
      definitions: {
        type: 'object',
        additionalProperties: { $ref: '#' },
        default: {},
      },
      properties: {
        type: 'object',
        additionalProperties: { $ref: '#' },
        default: {},
      },
      patternProperties: {
        type: 'object',
        additionalProperties: { $ref: '#' },
        default: {},
      },
      dependencies: {
        type: 'object',
        additionalProperties: {
          anyOf: [{ $ref: '#' }, { $ref: '#/definitions/stringArray' }],
        },
      },
      enum: {
        type: 'array',
        minItems: 1,
        uniqueItems: true,
      },
      type: {
        anyOf: [
          { $ref: '#/definitions/simpleTypes' },
          {
            type: 'array',
            items: { $ref: '#/definitions/simpleTypes' },
            minItems: 1,
            uniqueItems: true,
          },
        ],
      },
      allOf: { $ref: '#/definitions/schemaArray' },
      anyOf: { $ref: '#/definitions/schemaArray' },
      oneOf: { $ref: '#/definitions/schemaArray' },
      not: { $ref: '#' },
    },
    dependencies: {
      exclusiveMaximum: ['maximum'],
      exclusiveMinimum: ['minimum'],
    },
    default: {},
  };

  class ValidationErrors {
    constructor(jsonErrors) {
      this.length = jsonErrors ? jsonErrors.length : 0;

      if (this.length > 0) {
        for (let i = 0; i < this.length; i++) {
          this[i] = jsonErrors[i];
        }
      }
    }
  }

  var validationErrors = {
    ValidationErrors
  };

  const { ValidationErrors: ValidationErrors$1 } = validationErrors;

  const SCHEMA_V3 = 'http://json-schema.org/draft-03/schema';
  const SCHEMA_V4 = 'http://json-schema.org/draft-04/schema';

  /**
   * @param {Object} schema
   * @returns {[Object, string] | null} Tuple of [schemaMeta, schemaVersion]
   */
  const getSchemaMeta = (schema) => {
    if (schema && schema.$schema && schema.$schema.includes(SCHEMA_V3)) {
      return [metaSchemaV3, 'v3'];
    }

    if (schema && schema.$schema && schema.$schema.includes(SCHEMA_V4)) {
      return [metaSchemaV4, 'v4'];
    }

    return null;
  };

  /**
   * Returns a proper article for a given string.
   * @param {string} str
   * @returns {string}
   */
  function getArticle(str) {
    const vowels = ['a', 'e', 'i', 'o', 'u'];
    return vowels.includes(str.toLowerCase()) ? 'an' : 'a';
  }

  const jsonSchemaOptions = {
    singleError: false,
    messages: {
      minLength: (prop, val, validator) =>
        `The ${prop} property must be at least ${validator} characters long (currently ${val.length} characters long).`,
      maxLength: (prop, val, validator) =>
        `The ${prop} property must not exceed ${validator} characters (currently${val.length} characters long).`,
      length: (prop, val, validator) =>
        `The ${prop} property must be exactly ${validator} characters long (currently ${val.length} characters long).`,
      format: (prop, val, validator) =>
        `The ${prop} property must be ${getArticle(
        validator[0]
      )} ${validator} (current value is ${JSON.stringify(val)}).`,
      type: (prop, val, validator) =>
        `The ${prop} property must be ${getArticle(
        validator[0]
      )} ${validator} (current value is ${JSON.stringify(val)})."`,
      except: (prop, val) => `The ${prop} property must not be ${val}.`,
      minimum: (prop, val, validator) =>
        `The minimum value of the ${prop} must be ${validator} (current value is ${JSON.stringify(
        val
      )}).`,
      maximum: (prop, val, validator) =>
        `The maximum value of the ${prop} must be ${validator} (current value is ${JSON.stringify(
        val
      )}).`,
      pattern: (prop, val, validator) =>
        `The ${prop} value (${val}) does not match the ${validator} pattern.`,
      maxItems: (prop, val, validator) =>
        `The ${prop} property must not contain more than ${validator} items (currently contains ${val.length} items).`,
      minItems: (prop, val, validator) =>
        `The ${prop} property must contain at least ${validator} items (currently contains ${val.length} items).`,
      divisibleBy: (prop, val, validator) =>
        `The ${prop} property is not divisible by ${validator} (current value is ${JSON.stringify(
        val
      )}).`,
      uniqueItems: (prop) => `All items in the ${prop} property must be unique.`
    }
  };

  class JsonSchema {
    /**
     * Constructs a JsonValidator and validates given data.
     * @param {Object | string} schema
     * @param {Object | string} data
     */
    constructor(schema, data) {
      this.schema = schema;
      this.data = data;

      if (typeof this.data === 'string') {
        try {
          this.data = parseJson_1(this.data);
        } catch (error) {
          const outError = new errors.DataNotJsonParsableError(
            `JSON validator: body: ${error.message}`
          );
          outError.data = this.data;
          throw outError;
        }
      }

      if (typeof this.schema === 'string') {
        try {
          this.schema = parseJson_1(this.schema);
        } catch (error) {
          const outError = new errors.SchemaNotJsonParsableError(
            `JSON validator: schema: ${error.message}`
          );
          outError.schema = this.schema;
          throw outError;
        }
      }

      this.jsonSchemaVersion = null;
      this.validateSchema();
    }

    validateSchema() {
      const [metaSchema, schemaVersion] = getSchemaMeta(this.schema) || [];

      if (metaSchema) {
        this.jsonSchemaVersion = schemaVersion;

        if (metaSchema.$schema) {
          tv4.reset();
          tv4.addSchema('', metaSchema);
          tv4.addSchema(metaSchema.$schema, metaSchema);
          const validationResult = tv4.validateResult(this.schema, metaSchema);
          if (!validationResult.valid) {
            throw new errors.JsonSchemaNotValid(
              `JSON schema is not valid draft ${this.jsonSchemaVersion}! ${validationResult.error.message} at path "${validationResult.error.dataPath}"`
            );
          }
        }
      } else {
        if (metaSchemaV3.$schema) {
          tv4.reset();
          tv4.addSchema('', metaSchemaV3);
          tv4.addSchema(metaSchemaV3.$schema, metaSchemaV3);
          const validationResult = tv4.validateResult(this.schema, metaSchemaV3);

          if (validationResult && validationResult.valid) {
            this.jsonSchemaVersion = 'v3';
            return;
          }
        }

        if (metaSchemaV4.$schema) {
          tv4.reset();
          tv4.addSchema('', metaSchemaV4);
          tv4.addSchema(metaSchemaV4.$schema, metaSchemaV4);
          const validationResult = tv4.validateResult(this.schema, metaSchemaV4);

          if (validationResult && validationResult.valid) {
            this.jsonSchemaVersion = 'v4';
            return;
          }
        }

        if (this.jsonSchemaVersion === null) {
          throw new errors.JsonSchemaNotValid(
            'JSON schema is not valid draft v3 or draft v4!'
          );
        }
      }
    }

    validate() {
      if (
        this.data !== null &&
        typeof this.data === 'object' &&
        this.schema.empty
      ) {
        this.output = {
          length: 0,
          errorMessages: {}
        };
        return new ValidationErrors$1(this.output);
      }

      const hasSameData = deepEqual_1(this.data, this.usedData, { strict: true });
      const hasSameSchema = hasSameData
        ? deepEqual_1(this.schema, this.usedSchema, { strict: true })
        : true;

      if (!hasSameData || !hasSameSchema) {
        this.output = this.validatePrivate();
      }

      return this.output;
    }

    validatePrivate() {
      this.usedData = this.data;
      this.usedSchema = this.schema;

      switch (this.jsonSchemaVersion) {
        case 'v3':
          return this.validateSchemaV3();
        case 'v4':
          return this.validateSchemaV4();
        default:
          throw new Error("JSON schema version not identified, can't validate!");
      }
    }

    /**
     * Converts TV4 output to Gavel results.
     */
    evaluateOutputToResults(data) {
      if (!data) {
        data = this.output;
      }

      if (!data) {
        return [];
      }

      const results = Array.from({ length: data.length }, (_, index) => {
        const item = data[index];
        const { message, property } = item;
        let pathArray = [];

        if (property === null) {
          pathArray = [];
        } else if (
          Array.isArray(property) &&
          property.length === 1 &&
          [null, undefined].includes(property[0])
        ) {
          pathArray = [];
        } else {
          pathArray = property;
        }

        return {
          message,
          location: {
            pointer: jsonPointer.compile(pathArray),
            property
          }
        };
      });

      return results;
    }

    validateSchemaV3() {
      try {
        return amanda.validate(
          this.data,
          this.schema,
          jsonSchemaOptions,
          (error) => {
            if (error && error.length > 0) {
              for (let i = 0; i < error.length; i++) {
                if (error[i].property === '') {
                  error[i].property = [];
                }
              }
              this.errors = new ValidationErrors$1(error);
              return this.errors;
            }
          }
        );
      } catch (error) {
        this.errors = new ValidationErrors$1({
          '0': {
            property: [],
            attributeValue: true,
            message: `Validator internal error: ${error.message}`,
            validatorName: 'error'
          },
          length: 1,
          errorMessages: {}
        });

        return this.errors;
      }
    }

    validateSchemaV4() {
      const result = tv4.validateMultiple(this.data, this.schema);
      const validationErrors = result.errors.concat(result.missing);

      const amandaCompatibleError = {
        length: validationErrors.length,
        errorMessages: {}
      };

      for (let index = 0; index < validationErrors.length; index++) {
        const validationError = validationErrors[index];
        let error;

        if (validationError instanceof Error) {
          error = validationError;
        } else {
          error = new Error('Missing schema');
          error.params = { key: validationError };
          error.dataPath = '';
        }

        const pathArray = jsonPointer
          .parse(error.dataPath)
          .concat(error.params.key || []);
        const pointer = jsonPointer.compile(pathArray);

        amandaCompatibleError[index] = {
          message: `At '${pointer}' ${error.message}`,
          property: pathArray,
          attributeValue: true,
          validatorName: 'error'
        };
      }

      this.errors = new ValidationErrors$1(amandaCompatibleError);
      return this.errors;
    }
  }

  var jsonSchema = {
    JsonSchema
  };

  const nativeJsObjects = {
    '[object Arguments]': 'arguments',
    '[object Array]': 'array',
    '[object Date]': 'date',
    '[object Function]': 'function',
    '[object Number]': 'number',
    '[object RegExp]': 'regexp',
    '[object String]': 'string',
    '[object Null]': 'null',
    '[object Undefined]': 'undefined',
    '[object Object]': 'object'
  };

  function stringifyType(any) {
    return Object.prototype.toString.call(any);
  }

  function getType(any) {
    const type = stringifyType(any);

    return Object.prototype.hasOwnProperty.call(nativeJsObjects, type)
      ? nativeJsObjects[type]
      : typeof any;
  }

  var getType_1 = getType;

  const SCHEMA_VERSION = 'http://json-schema.org/draft-04/schema#';

  class SchemaV4Properties {
    /**
     * @param {boolean} keyStrict
     * @param {string[] | boolean} valuesStrict
     * @param {boolean} typesStrict
     */
    constructor({ keysStrict, valuesStrict, typesStrict }) {
      this.set({ keysStrict, valuesStrict, typesStrict });
    }

    /**
     * @option {boolean} keyStrict
     * @option {string[] | boolean} valuesStrict
     * @option {boolean} typesStrict
     */
    set({ keysStrict, valuesStrict, typesStrict }) {
      this.keysStrict = keysStrict || false;
      this.valuesStrict = valuesStrict || false;
      this.typesStrict = typesStrict || false;
    }
  }

  class SchemaV4Generator {
    /**
     * @option {Object} json
     * @option {SchemaProperties} properties
     */
    constructor({ json, properties }) {
      this.json = typeof json === 'string' ? parseJson_1(json) : json;

      this.schema = undefined;
      this.properties = properties || new SchemaV4Properties({});

      if (Array.isArray(this.properties.valuesStrict)) {
        this.properties.valuesStrict = this.properties.valuesStrict.map((value) =>
          value.toLowerCase()
        );
      }
    }

    /**
     * @returns {Object} Generated JSON schema.
     */
    generate() {
      this.schema = this.getSchemaForObject({
        baseObject: this.json,
        objectId: undefined,
        firstLevel: true,
        properties: this.properties
      });

      return this.schema;
    }

    getSchemaTypeFor(value) {
      const valueType = getType_1(value);

      if (value === null) {
        return 'null';
      }
      if (valueType === 'array') {
        return 'array';
      }
      if (valueType === 'number' && value % 1 === 0) {
        return 'integer';
      }

      return valueType;
    }

    isBaseType(type) {
      return !['array', 'object'].includes(type);
    }

    getSchemaForObject({ baseObject, objectId, firstLevel, properties }) {
      let getSchemaForObjectProperties;
      if (firstLevel == null) {
        firstLevel = true;
      }

      if (!properties) {
        properties = new SchemaV4Properties();
      }
      const schemaDict = {};

      if (firstLevel) {
        schemaDict.$schema = SCHEMA_VERSION;
        schemaDict.id = '#';
      }

      if (objectId != null) {
        schemaDict.id = objectId;
      }

      const schemaType = this.getSchemaTypeFor(baseObject);

      const hasKeys =
        baseObject !== null &&
        typeof baseObject === 'object' &&
        Object.keys(baseObject).length > 0;

      if (schemaType === 'object') {
        if (properties.keysStrict) {
          schemaDict.additionalProperties = false;
        } else {
          schemaDict.additionalProperties = true;
        }
      } else if (schemaType === 'array') {
        if (properties.keysStrict) {
          schemaDict.additionalItems = false;
        } else {
          schemaDict.additionalItems = true;
        }
      }

      if (properties.valuesStrict === true && this.isBaseType(schemaType)) {
        schemaDict.enum = [baseObject];
      } else if (
        Array.isArray(properties.valuesStrict) &&
        this.isBaseType(schemaType)
      ) {
        if (
          properties.valuesStrict.indexOf(
            objectId != null ? objectId.toLowerCase() : undefined
          ) > -1
        ) {
          schemaDict.enum = [baseObject];
        }
      }

      if (
        (properties.typesStrict && this.isBaseType(schemaType)) ||
        !this.isBaseType(schemaType) ||
        firstLevel === true
      ) {
        schemaDict.type = schemaType;
      }

      if (schemaType === 'object' && hasKeys) {
        schemaDict.required = [];
        schemaDict.properties = {};

        Object.keys(baseObject || {}).forEach((prop) => {
          const value = baseObject[prop];
          getSchemaForObjectProperties = {
            baseObject: value,
            objectId: prop,
            firstLevel: false,
            properties
          };
          schemaDict.properties[prop] = this.getSchemaForObject(
            getSchemaForObjectProperties
          );
          schemaDict.required.push(prop);
        });
      } else if (schemaType === 'array' && baseObject.length > 0) {
        schemaDict.items = [];

        for (let itemIndex = 0; itemIndex < baseObject.length; itemIndex++) {
          const item = baseObject[itemIndex];
          getSchemaForObjectProperties = {
            baseObject: item,
            objectId: itemIndex.toString(),
            firstLevel: false,
            properties
          };
          schemaDict.items.push(
            this.getSchemaForObject(getSchemaForObjectProperties)
          );
        }
      }

      return schemaDict;
    }
  }

  var schemaV4Generator = {
    SchemaV4Properties,
    SchemaV4Generator
  };

  function Caseless (dict) {
    this.dict = dict || {};
  }
  Caseless.prototype.set = function (name, value, clobber) {
    if (typeof name === 'object') {
      for (var i in name) {
        this.set(i, name[i], value);
      }
    } else {
      if (typeof clobber === 'undefined') clobber = true;
      var has = this.has(name);

      if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value;
      else this.dict[has || name] = value;
      return has
    }
  };
  Caseless.prototype.has = function (name) {
    var keys = Object.keys(this.dict)
      , name = name.toLowerCase()
      ;
    for (var i=0;i<keys.length;i++) {
      if (keys[i].toLowerCase() === name) return keys[i]
    }
    return false
  };
  Caseless.prototype.get = function (name) {
    name = name.toLowerCase();
    var result, _key;
    var headers = this.dict;
    Object.keys(headers).forEach(function (key) {
      _key = key.toLowerCase();
      if (name === _key) result = headers[key];
    });
    return result
  };
  Caseless.prototype.swap = function (name) {
    var has = this.has(name);
    if (has === name) return
    if (!has) throw new Error('There is no header than matches "'+name+'"')
    this.dict[name] = this.dict[has];
    delete this.dict[has];
  };
  Caseless.prototype.del = function (name) {
    var has = this.has(name);
    return delete this.dict[has || name]
  };

  var caseless = function (dict) {return new Caseless(dict)};
  var httpify = function (resp, headers) {
    var c = new Caseless(headers);
    resp.setHeader = function (key, value, clobber) {
      if (typeof value === 'undefined') return
      return c.set(key, value, clobber)
    };
    resp.hasHeader = function (key) {
      return c.has(key)
    };
    resp.getHeader = function (key) {
      return c.get(key)
    };
    resp.removeHeader = function (key) {
      return c.del(key)
    };
    resp.headers = c.dict;
    return c
  };
  caseless.httpify = httpify;

  var tv4ToHeadersMessage = (message, expectedHeaders) => {
    let newMessage;

    if (message.includes('Missing required property:')) {
      const headerName = message.split('Missing required property: ')[1];
      newMessage = `Header '${headerName}' is missing`;
    } else if (message.includes('No enum match for: ')) {
      const splitted = message.split('\' No enum match for: "');
      const headerName = splitted[0].replace(/^At '\//, '');
      const headerValue = splitted[1].replace(/"$/, '');

      const expected = caseless(expectedHeaders).get(headerName);
      newMessage = `Header '${headerName}' has value '${headerValue}' instead of '${expected}'`;
    } else {
      throw new Error(
        "Unknown tv4 error message can't convert to headers message."
      );
    }

    return newMessage;
  };

  const { JsonSchema: JsonSchema$1 } = jsonSchema;
  const {
    SchemaV4Generator: SchemaV4Generator$1,
    SchemaV4Properties: SchemaV4Properties$1
  } = schemaV4Generator;


  const prepareHeaders = (headers) => {
    if (typeof headers !== 'object') {
      return headers;
    }

    const transformedHeaders = Object.keys(headers).reduce((acc, key) => {
      return Object.assign({}, acc, { [key.toLowerCase()]: headers[key] });
    }, {});

    return transformedHeaders;
  };

  const getSchema = (json) => {
    const properties = new SchemaV4Properties$1({
      keysStrict: false,
      typesStrict: false,
      valuesStrict: [
        'content-type',
        'accept',
        'accept-charset',
        'accept-encoding',
        'accept-language'
      ]
    });

    const schemaGenerator = new SchemaV4Generator$1({ json, properties });
    return schemaGenerator.generate();
  };

  class HeadersJsonExample extends JsonSchema$1 {
    constructor(expected, actual) {
      if (typeof actual !== 'object') {
        throw new errors.MalformedDataError('Actual is not an Object');
      }

      if (typeof expected !== 'object') {
        throw new errors.MalformedDataError('Expected is not an Object');
      }

      const preparedExpected = prepareHeaders(expected);
      const preparedActual = prepareHeaders(actual);
      const preparedSchema = getSchema(preparedExpected);

      if (preparedSchema && preparedSchema.properties) {
        const skippedHeaders = ['date', 'expires'];
        skippedHeaders.forEach((headerName) => {
          if (preparedSchema.properties[headerName]) {
            delete preparedSchema.properties[headerName].enum;
          }
        });
      }

      super(preparedSchema, preparedActual);

      this.expected = preparedExpected;
      this.actual = preparedActual;
      this.schema = preparedSchema;
    }

    validate() {
      const result = super.validate();

      if (result.length > 0) {
        const resultCopy = clone_1(result, false);

        for (let i = 0; i < result.length; i++) {
          resultCopy[i].message = tv4ToHeadersMessage(
            resultCopy[i].message,
            this.expected
          );
        }

        return resultCopy;
      }

      return result;
    }
  }

  var headersJsonExample = {
    HeadersJsonExample
  };

  class TextDiff {
    constructor(expected, actual) {
      if (typeof actual !== 'string') {
        const outError = new errors.DataNotStringError(
          'String validator actual: input data is not string'
        );
        outError.data = actual;
        throw outError;
      }

      if (typeof expected !== 'string') {
        const outError = new errors.DataNotStringError(
          'String validator expected: input data is not string'
        );
        outError.data = expected;
        throw outError;
      }

      this.expected = expected;
      this.actual = actual;
    }

    validate() {
      this.valid = this.actual === this.expected;
      return this.valid;
    }

    evaluateOutputToResults() {
      if (this.valid) {
        return [];
      }

      return [
        {
          message: 'Actual and expected data do not match.'
        }
      ];
    }
  }

  var textDiff = { TextDiff };

  const { JsonSchema: JsonSchema$2 } = jsonSchema;
  const {
    SchemaV4Generator: SchemaV4Generator$2,
    SchemaV4Properties: SchemaV4Properties$2
  } = schemaV4Generator;

  function getSchema$1(json) {
    const properties = new SchemaV4Properties$2({
      keysStrict: false,
      valuesStrict: false,
      typesStrict: false
    });
    const schemaGenerator = new SchemaV4Generator$2({ json, properties });
    return schemaGenerator.generate();
  }

  class JsonExample extends JsonSchema$2 {
    /**
     * Construct a BodyValidator, check data and choose the right validator.
     * If actual and expected data are valid JSON, and a valid schema is given,
     * choose JsonValidator, otherwise choose StringValidator.
     * @param {string} expected
     * @param {string} actual
     * @throw {MalformedDataError} when actual is not a String or when no schema provided and expected is not a String
     * @throw {SchemaNotJsonParsableError} when given schema is not a json parsable string or valid json
     * @throw {NotEnoughDataError} when at least one of expected data and json schema is not given
     */
    constructor(expected, actual) {
      if (typeof actual !== 'string') {
        const outError = new errors.MalformedDataError(
          'JsonExample validator: provided actual data is not string'
        );
        outError.data = actual;
        throw outError;
      }

      if (typeof expected !== 'string') {
        const outError = new errors.MalformedDataError(
          'JsonExample validator: provided expected data is not string'
        );
        outError.data = expected;
        throw outError;
      }

      const schema = getSchema$1(expected);
      super(schema, actual);
    }
  }

  var jsonExample = {
    JsonExample
  };

  const { HeadersJsonExample: HeadersJsonExample$1 } = headersJsonExample;
  const { TextDiff: TextDiff$1 } = textDiff;
  const { JsonExample: JsonExample$1 } = jsonExample;
  const { JsonSchema: JsonSchema$3 } = jsonSchema;

  var validators = {
    HeadersJsonExample: HeadersJsonExample$1,
    TextDiff: TextDiff$1,
    JsonExample: JsonExample$1,
    JsonSchema: JsonSchema$3
  };

  const { HeadersJsonExample: HeadersJsonExample$2 } = validators;
  const { isValidField: isValidField$1 } = isValid;

  const APIARY_JSON_HEADER_TYPE = 'application/vnd.apiary.http-headers+json';

  function getHeadersType(headers) {
    return headers instanceof Object && !Array.isArray(headers)
      ? APIARY_JSON_HEADER_TYPE
      : null;
  }

  /**
   * Validates given real and expected transaction elements.
   * @param {Object<string, any>} expected
   * @param {Object<string, any>} real
   */
  function validateHeaders(expected, actual) {
    const values = {
      expected: expected.headers,
      actual: actual.headers
    };
    const expectedType = getHeadersType(values.expected);
    const actualType = getHeadersType(values.actual);
    const errors = [];

    const hasJsonHeaders =
      actualType === APIARY_JSON_HEADER_TYPE &&
      expectedType === APIARY_JSON_HEADER_TYPE;

    const validator = hasJsonHeaders
      ? new HeadersJsonExample$2(values.expected, values.actual)
      : null;

    // if you don't call ".validate()", it never evaluates any results.
    validator && validator.validate();

    if (validator) {
      errors.push(...validator.evaluateOutputToResults());
    } else {
      errors.push({
        message: `\
No validator found for real data media type
"${actualType}"
and expected data media type
"${expectedType}".\
`
      });
    }

    return {
      valid: isValidField$1({ errors }),
      kind: hasJsonHeaders ? 'json' : 'text',
      values,
      errors
    };
  }

  var validateHeaders_1 = { validateHeaders };

  /*!
   * media-typer
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */

  /**
   * RegExp to match type in RFC 6838
   *
   * type-name = restricted-name
   * subtype-name = restricted-name
   * restricted-name = restricted-name-first *126restricted-name-chars
   * restricted-name-first  = ALPHA / DIGIT
   * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
   *                          "$" / "&" / "-" / "^" / "_"
   * restricted-name-chars =/ "." ; Characters before first dot always
   *                              ; specify a facet name
   * restricted-name-chars =/ "+" ; Characters after last plus always
   *                              ; specify a structured syntax suffix
   * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
   * DIGIT =  %x30-39             ; 0-9
   */
  var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

  /**
   * Module exports.
   */

  var format_1 = format$1;
  var parse_1 = parse$1;
  var test_1 = test;

  /**
   * Format object to media type.
   *
   * @param {object} obj
   * @return {string}
   * @public
   */

  function format$1 (obj) {
    if (!obj || typeof obj !== 'object') {
      throw new TypeError('argument obj is required')
    }

    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type = obj.type;

    if (!type || !TYPE_NAME_REGEXP.test(type)) {
      throw new TypeError('invalid type')
    }

    if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {
      throw new TypeError('invalid subtype')
    }

    // format as type/subtype
    var string = type + '/' + subtype;

    // append +suffix
    if (suffix) {
      if (!TYPE_NAME_REGEXP.test(suffix)) {
        throw new TypeError('invalid suffix')
      }

      string += '+' + suffix;
    }

    return string
  }

  /**
   * Test media type.
   *
   * @param {string} string
   * @return {object}
   * @public
   */

  function test (string) {
    if (!string) {
      throw new TypeError('argument string is required')
    }

    if (typeof string !== 'string') {
      throw new TypeError('argument string is required to be a string')
    }

    return TYPE_REGEXP.test(string.toLowerCase())
  }

  /**
   * Parse media type to object.
   *
   * @param {string} string
   * @return {object}
   * @public
   */

  function parse$1 (string) {
    if (!string) {
      throw new TypeError('argument string is required')
    }

    if (typeof string !== 'string') {
      throw new TypeError('argument string is required to be a string')
    }

    var match = TYPE_REGEXP.exec(string.toLowerCase());

    if (!match) {
      throw new TypeError('invalid media type')
    }

    var type = match[1];
    var subtype = match[2];
    var suffix;

    // suffix after last +
    var index = subtype.lastIndexOf('+');
    if (index !== -1) {
      suffix = subtype.substr(index + 1);
      subtype = subtype.substr(0, index);
    }

    return new MediaType(type, subtype, suffix)
  }

  /**
   * Class for MediaType object.
   * @public
   */

  function MediaType (type, subtype, suffix) {
    this.type = type;
    this.subtype = subtype;
    this.suffix = suffix;
  }

  var mediaTyper = {
  	format: format_1,
  	parse: parse_1,
  	test: test_1
  };

  /*!
   * content-type
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  /**
   * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
   *
   * parameter     = token "=" ( token / quoted-string )
   * token         = 1*tchar
   * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
   *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
   *               / DIGIT / ALPHA
   *               ; any VCHAR, except delimiters
   * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
   * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
   * obs-text      = %x80-FF
   * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
   */
  var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
  var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

  /**
   * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
   *
   * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
   * obs-text    = %x80-FF
   */
  var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;

  /**
   * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
   */
  var QUOTE_REGEXP = /([\\"])/g;

  /**
   * RegExp to match type in RFC 7231 sec 3.1.1.1
   *
   * media-type = type "/" subtype
   * type       = token
   * subtype    = token
   */
  var TYPE_REGEXP$1 = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

  /**
   * Module exports.
   * @public
   */

  var format_1$1 = format$2;
  var parse_1$1 = parse$2;

  /**
   * Format object to media type.
   *
   * @param {object} obj
   * @return {string}
   * @public
   */

  function format$2 (obj) {
    if (!obj || typeof obj !== 'object') {
      throw new TypeError('argument obj is required')
    }

    var parameters = obj.parameters;
    var type = obj.type;

    if (!type || !TYPE_REGEXP$1.test(type)) {
      throw new TypeError('invalid type')
    }

    var string = type;

    // append parameters
    if (parameters && typeof parameters === 'object') {
      var param;
      var params = Object.keys(parameters).sort();

      for (var i = 0; i < params.length; i++) {
        param = params[i];

        if (!TOKEN_REGEXP.test(param)) {
          throw new TypeError('invalid parameter name')
        }

        string += '; ' + param + '=' + qstring(parameters[param]);
      }
    }

    return string
  }

  /**
   * Parse media type to object.
   *
   * @param {string|object} string
   * @return {Object}
   * @public
   */

  function parse$2 (string) {
    if (!string) {
      throw new TypeError('argument string is required')
    }

    // support req/res-like objects as argument
    var header = typeof string === 'object'
      ? getcontenttype(string)
      : string;

    if (typeof header !== 'string') {
      throw new TypeError('argument string is required to be a string')
    }

    var index = header.indexOf(';');
    var type = index !== -1
      ? header.substr(0, index).trim()
      : header.trim();

    if (!TYPE_REGEXP$1.test(type)) {
      throw new TypeError('invalid media type')
    }

    var obj = new ContentType(type.toLowerCase());

    // parse parameters
    if (index !== -1) {
      var key;
      var match;
      var value;

      PARAM_REGEXP.lastIndex = index;

      while ((match = PARAM_REGEXP.exec(header))) {
        if (match.index !== index) {
          throw new TypeError('invalid parameter format')
        }

        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];

        if (value[0] === '"') {
          // remove quotes and escapes
          value = value
            .substr(1, value.length - 2)
            .replace(QESC_REGEXP, '$1');
        }

        obj.parameters[key] = value;
      }

      if (index !== header.length) {
        throw new TypeError('invalid parameter format')
      }
    }

    return obj
  }

  /**
   * Get content-type from req/res objects.
   *
   * @param {object}
   * @return {Object}
   * @private
   */

  function getcontenttype (obj) {
    var header;

    if (typeof obj.getHeader === 'function') {
      // res-like
      header = obj.getHeader('content-type');
    } else if (typeof obj.headers === 'object') {
      // req-like
      header = obj.headers && obj.headers['content-type'];
    }

    if (typeof header !== 'string') {
      throw new TypeError('content-type header is missing from object')
    }

    return header
  }

  /**
   * Quote a string if necessary.
   *
   * @param {string} val
   * @return {string}
   * @private
   */

  function qstring (val) {
    var str = String(val);

    // no need to quote tokens
    if (TOKEN_REGEXP.test(str)) {
      return str
    }

    if (str.length > 0 && !TEXT_REGEXP.test(str)) {
      throw new TypeError('invalid parameter value')
    }

    return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
  }

  /**
   * Class to represent a content type.
   * @private
   */
  function ContentType (type) {
    this.parameters = Object.create(null);
    this.type = type;
  }

  var contentType = {
  	format: format_1$1,
  	parse: parse_1$1
  };

  const { isValidField: isValidField$2 } = isValid;
  const { TextDiff: TextDiff$2, JsonExample: JsonExample$2, JsonSchema: JsonSchema$4 } = validators;



  function isPlainText(mediaType) {
    return mediaType.type === 'text' && mediaType.subtype === 'plain';
  }

  function isJson(mediaType) {
    if (!mediaType) {
      return false;
    }

    return (
      (mediaType.type === 'application' && mediaType.subtype === 'json') ||
      mediaType.suffix === 'json'
    );
  }

  function isJsonSchema(mediaType) {
    if (!mediaType) {
      return false;
    }

    return (
      mediaType.type === 'application' &&
      mediaType.subtype === 'schema' &&
      mediaType.suffix === 'json'
    );
  }

  /**
   * Parses a given content-type header into media type.
   * @param {string} contentType
   * @returns {[Error, MediaType]}
   */
  function parseContentType(contentType$1) {
    try {
      const { type } = contentType.parse(`${contentType$1}`);
      return mediaTyper.parse(type);
    } catch (error) {
      return null;
    }
  }

  /**
   * Determines if a given 'Content-Type' header contains JSON.
   * @param {string} contentType
   * @returns {boolean}
   */
  function isJsonContentType(contentType) {
    const mediaType = parseContentType(contentType);
    return mediaType ? isJson(mediaType) : false;
  }

  /**
   * Returns a tuple of error and body media type based
   * on the given body and normalized headers.
   * @param {string} body
   * @param {string} contentType
   * @param {'actual'|'expected'} httpMessageOrigin
   * @returns {[string, MediaType]}
   */
  function getBodyType(body, contentType, httpMessageOrigin) {
    const hasJsonContentType = isJsonContentType(contentType);

    try {
      parseJson_1(body);

      const bodyMediaType = parseContentType(
        hasJsonContentType ? contentType : 'application/json'
      );

      return [null, bodyMediaType];
    } catch (parsingError) {
      const fallbackMediaType = mediaTyper.parse('text/plain');
      const error = hasJsonContentType
        ? `Can't validate: ${httpMessageOrigin} body 'Content-Type' header is '${contentType}' \
but body is not a parseable JSON:
${parsingError.message}`
        : null;

      return [error, fallbackMediaType];
    }
  }

  /**
   * Returns a tuple of error and schema media type
   * based on given body schema.
   * @param {string} bodySchema
   * @returns {[string, string]}
   */
  function getBodySchemaType(bodySchema) {
    const jsonSchemaType = mediaTyper.parse('application/schema+json');

    if (typeof bodySchema !== 'string') {
      return [null, jsonSchemaType];
    }

    try {
      parseJson_1(bodySchema);
      return [null, jsonSchemaType];
    } catch (error) {
      // Gavel must throw when given malformed JSON Schema.
      // See https://github.com/apiaryio/gavel.js/issues/203
      throw new Error(`\
Failed to validate HTTP message "body": given JSON Schema is not a valid JSON.

${error.message}\
`);
    }
  }

  /**
   * Returns a body validator class based on the given
   * actual and expected body media types.
   * @param {MediaType} expectedType
   * @param {MediaType} actualType
   * @returns {Validator}
   */
  function getBodyValidator(expectedType, actualType) {
    const both = (predicate) => (expected, actual) => {
      return [expected, actual].every(predicate);
    };

    const validators = [
      [TextDiff$2, both(isPlainText), 'text'],
      // List JsonSchema first, because weak predicate of JsonExample
      // would resolve on "application/schema+json" media type too.
      [
        JsonSchema$4,
        (expected, actual) => {
          return isJson(actual) && isJsonSchema(expected);
        },
        'json'
      ],
      [JsonExample$2, both(isJson), 'json']
    ];

    const validator = validators.find(([_name, predicate]) => {
      return predicate(expectedType, actualType);
    });

    if (!validator) {
      const error = `Can't validate actual media type '${mediaTyper.format(
      actualType
    )}' against the expected media type '${mediaTyper.format(expectedType)}'.`;
      return [error, null, null];
    }

    return [null, validator[0], validator[2]];
  }

  /**
   * Validates given bodies of transaction elements.
   * @param {Object<string, any>} expected
   * @param {Object<string, any>} actual
   */
  function validateBody(expected, actual) {
    const values = {
      actual: actual.body
    };

    // Prevent assigning { expected: undefined }.
    // Also ignore "bodySchema" as the expected value.
    if (isset_1(expected.body)) {
      values.expected = expected.body;
    }

    const errors = [];
    const actualBodyType = typeof actual.body;
    const hasEmptyActualBody = actual.body === '';

    // Throw when user input for actual body is not a string.
    if (actualBodyType !== 'string') {
      throw new Error(
        `Expected HTTP body to be a string, but got: ${actualBodyType}`
      );
    }

    const [actualTypeError, actualType] = getBodyType(
      actual.body,
      actual.headers && actual.headers['content-type'],
      'actual'
    );

    const [expectedTypeError, expectedType] = expected.bodySchema
      ? getBodySchemaType(expected.bodySchema)
      : getBodyType(
          expected.body,
          expected.headers && expected.headers['content-type'],
          'expected'
        );

    if (actualTypeError) {
      errors.push({
        message: actualTypeError
      });
    }

    if (expectedTypeError) {
      errors.push({
        message: expectedTypeError
      });
    }

    const hasErrors = errors.length > 0;

    // Skipping body validation in case errors during
    // actual/expected body type definition.
    const [validatorError, ValidatorClass, kind] = hasErrors
      ? [null, null, null]
      : getBodyValidator(expectedType, actualType);

    if (validatorError) {
      // In case determined media types mismtach, check if the actual is not missing.
      // Keep in mind the following scenarios:
      // 1. Expected '', and got '' (TextDiff/TextDiff, valid)
      // 2. Expected {...}, but got '' (Json/TextDiff, invalid, produces "missing actual body" error)
      // 3. Expected {...}, but got "foo" (Json/TextDiff, invalid, produces types mismatch error).
      if (expected.body !== '' && hasEmptyActualBody) {
        errors.push({
          message: `Expected "body" of "${mediaTyper.format(
          expectedType
        )}" media type, but actual "body" is missing.`
        });
      } else {
        errors.push({
          message: validatorError
        });
      }
    }

    const usesJsonSchema = ValidatorClass && ValidatorClass.name === 'JsonSchema';
    const validator =
      ValidatorClass &&
      new ValidatorClass(
        usesJsonSchema ? expected.bodySchema : expected.body,
        actual.body
      );

    // Calling "validate()" often updates an internal state of a validator.
    // That state is later used to output the gavel-compliant results.
    // Cannot remove until validators are refactored into simple functions.
    // @see https://github.com/apiaryio/gavel.js/issues/150
    validator && validator.validate();
    const validationErrors = validator ? validator.evaluateOutputToResults() : [];
    errors.push(...validationErrors);

    return {
      valid: isValidField$2({ errors }),
      kind,
      values,
      errors
    };
  }

  var validateBody_1 = {
    validateBody,

    isJson,
    isJsonSchema,
    isJsonContentType,
    parseContentType,
    getBodyType,
    getBodySchemaType,
    getBodyValidator
  };

  const { coerce: coerce$1, coerceWeak: coerceWeak$1 } = coerce_1;
  const { normalize: normalize$1 } = normalize_1;
  const { isValidResult: isValidResult$1 } = isValid;
  const { validateMethod: validateMethod$1 } = validateMethod_1;
  const { validateURI: validateURI$1 } = validateURI_1;
  const { validateStatusCode: validateStatusCode$1 } = validateStatusCode_1;
  const { validateHeaders: validateHeaders$1 } = validateHeaders_1;
  const { validateBody: validateBody$1 } = validateBody_1;

  function validate(expectedMessage, actualMessage) {
    const result = {};
    const fields = {};

    // Uses strict coercion on real message.
    // Strict coercion ensures that real message always has properties
    // illegible for validation with the expected message, even if they
    // are not present in the real message.
    const actual = normalize$1(coerce$1(actualMessage));

    // Use weak coercion on expected message.
    // Weak coercion will transform only the properties present in the
    // expected message. Properties meant for coercion, but not provided
    // in the expected message are left out, as we don't want to mutate
    // user's assertion.
    const expected = normalize$1(coerceWeak$1(expectedMessage));

    if (expected.method) {
      fields.method = validateMethod$1(expected, actual);
    }

    if (expected.uri) {
      fields.uri = validateURI$1(expected, actual);
    }

    if (expected.statusCode) {
      fields.statusCode = validateStatusCode$1(expected, actual);
    }

    if (expected.headers) {
      fields.headers = validateHeaders$1(expected, actual);
    }

    if (isset_1(expected.body) || isset_1(expected.bodySchema)) {
      fields.body = validateBody$1(expected, actual);
    }

    // Indicates the validity of the actual message
    result.valid = isValidResult$1(fields);
    result.fields = fields;

    return result;
  }

  var validate_1 = { validate };

  const { validate: validate$1 } = validate_1;

  var lib = {
    validate: validate$1
  };
  var lib_1 = lib.validate;

  exports.default = lib;
  exports.validate = lib_1;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.js.map
